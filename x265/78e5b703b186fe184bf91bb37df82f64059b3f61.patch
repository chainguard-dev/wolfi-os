From 78e5b703b186fe184bf91bb37df82f64059b3f61 Mon Sep 17 00:00:00 2001
From: AnusuyaKumarasamy <anusuya.kumarasamy@multicorewareinc.com>
Date: Fri, 27 Sep 2024 16:54:55 +0530
Subject: [PATCH] Reverted the api changes

---
 source/abrEncApp.cpp            |  13 ++--
 source/encoder/api.cpp          |   4 +-
 source/encoder/encoder.cpp      | 126 ++++++++++++++++----------------
 source/encoder/encoder.h        |   2 +-
 source/encoder/frameencoder.cpp |   2 +-
 source/x265.h                   |   4 +-
 6 files changed, 75 insertions(+), 76 deletions(-)

diff --git a/source/abrEncApp.cpp b/source/abrEncApp.cpp
index 3462aa5c6..c5dcf3559 100644
--- a/source/abrEncApp.cpp
+++ b/source/abrEncApp.cpp
@@ -596,11 +596,10 @@ ret:
                 pic_in[view] = &pic_orig[view];
             /* Allocate recon picture if analysis save/load is enabled */
             std::priority_queue<int64_t>* pts_queue = m_cliopt.output->needPTS() ? new std::priority_queue<int64_t>() : NULL;
-            x265_picture* pic_recon[MAX_LAYERS];
+            x265_picture* pic_recon;
             x265_picture pic_out[MAX_LAYERS];
 
-            for (int i = 0; i < m_param->numLayers; i++)
-                pic_recon[i] = (m_cliopt.recon[i] || m_param->analysisSave || m_param->analysisLoad || pts_queue || reconPlay || m_param->csvLogLevel) ? &pic_out[i] : NULL;
+            pic_recon = (m_cliopt.recon || m_param->analysisSave || m_param->analysisLoad || pts_queue || reconPlay || m_param->csvLogLevel) ? pic_out : NULL;
             uint32_t inFrameCount = 0;
             uint32_t outFrameCount = 0;
             x265_nal *p_nal;
@@ -809,7 +808,7 @@ ret:
                     }
 
                     if (reconPlay && numEncoded)
-                        reconPlay->writePicture(*pic_recon[0]);
+                        reconPlay->writePicture(*pic_recon);
 
                     outFrameCount += numEncoded;
 
@@ -820,7 +819,7 @@ ret:
 
                     for (int layer = 0; layer < m_param->numLayers; layer++)
                     {
-                        if (numEncoded && pic_recon[layer] && m_cliopt.recon[layer])
+                        if (numEncoded && pic_recon && m_cliopt.recon[layer])
                             m_cliopt.recon[layer]->writePicture(pic_out[layer]);
                     }
                     if (nal)
@@ -848,7 +847,7 @@ ret:
                 }
 
                 if (reconPlay && numEncoded)
-                    reconPlay->writePicture(*pic_recon[0]);
+                    reconPlay->writePicture(*pic_recon);
 
                 outFrameCount += numEncoded;
                 if (isAbrSave && numEncoded)
@@ -858,7 +857,7 @@ ret:
 
                 for (int layer = 0; layer < m_param->numLayers; layer++)
                 {
-                    if (numEncoded && pic_recon[layer] && m_cliopt.recon[layer])
+                    if (numEncoded && pic_recon && m_cliopt.recon[layer])
                         m_cliopt.recon[layer]->writePicture(pic_out[layer]);
                 }
                 if (nal)
diff --git a/source/encoder/api.cpp b/source/encoder/api.cpp
index 9260a4fe3..06dcbf2e1 100644
--- a/source/encoder/api.cpp
+++ b/source/encoder/api.cpp
@@ -412,7 +412,7 @@ void x265_configure_vbv_end(x265_encoder* enc, x265_picture* picture, double tot
          picture->vbvEndFlag = 1;
     }
 }
-int x265_encoder_encode(x265_encoder *enc, x265_nal **pp_nal, uint32_t *pi_nal, x265_picture *pic_in, x265_picture **pic_out)
+int x265_encoder_encode(x265_encoder* enc, x265_nal** pp_nal, uint32_t* pi_nal, x265_picture* pic_in, x265_picture* pic_out)
 {
     if (!enc)
         return -1;
@@ -610,7 +610,7 @@ fail:
     if (numEncoded && encoder->m_param->csvLogLevel && encoder->m_outputCount >= encoder->m_latestParam->chunkStart)
     {
         for (int layer = 0; layer < encoder->m_param->numLayers; layer++)
-            x265_csvlog_frame(encoder->m_param, pic_out[layer]);
+            x265_csvlog_frame(encoder->m_param, pic_out + layer);
     }
 
     if (numEncoded < 0)
diff --git a/source/encoder/encoder.cpp b/source/encoder/encoder.cpp
index b14f89511..376d89d1f 100644
--- a/source/encoder/encoder.cpp
+++ b/source/encoder/encoder.cpp
@@ -1471,7 +1471,7 @@ bool Encoder::generateMcstfRef(Frame* frameEnc, FrameEncoder* currEncoder)
  * returns 0 if no frames are currently available for output
  *         1 if frame was output, m_nalList contains access unit
  *         negative on malloc error or abort */
-int Encoder::encode(const x265_picture* pic_in, x265_picture** pic_out)
+int Encoder::encode(const x265_picture* pic_in, x265_picture* pic_out)
 {
 #if CHECKED_BUILD || _DEBUG
     if (g_checkFailures)
@@ -1975,95 +1975,95 @@ int Encoder::encode(const x265_picture* pic_in, x265_picture** pic_out)
                 /* Free up inputPic->analysisData since it has already been used */
                 if ((m_param->analysisLoad && !m_param->analysisSave) || ((m_param->bAnalysisType == AVC_INFO) && slice->m_sliceType != I_SLICE))
                     x265_free_analysis_data(m_param, &outFrame->m_analysisData);
-                if (pic_out[sLayer])
+                if (pic_out && (&pic_out[sLayer]))
                 {
                     PicYuv* recpic = outFrame->m_reconPic[0];
-                    pic_out[sLayer]->poc = slice->m_poc;
-                    pic_out[sLayer]->bitDepth = X265_DEPTH;
-                    pic_out[sLayer]->userData = outFrame->m_userData;
-                    pic_out[sLayer]->colorSpace = m_param->internalCsp;
-                    pic_out[sLayer]->frameData.tLayer = outFrame->m_tempLayer;
-                    pic_out[sLayer]->layerID = sLayer;
-                    frameData = &(pic_out[sLayer]->frameData);
-
-                    pic_out[sLayer]->pts = outFrame->m_pts;
-                    pic_out[sLayer]->dts = outFrame->m_dts;
-                    pic_out[sLayer]->reorderedPts = outFrame->m_reorderedPts;
-                    pic_out[sLayer]->sliceType = outFrame->m_lowres.sliceType;
-                    pic_out[sLayer]->planes[0] = recpic->m_picOrg[0];
-                    pic_out[sLayer]->stride[0] = (int)(recpic->m_stride * sizeof(pixel));
+                    pic_out[sLayer].poc = slice->m_poc;
+                    pic_out[sLayer].bitDepth = X265_DEPTH;
+                    pic_out[sLayer].userData = outFrame->m_userData;
+                    pic_out[sLayer].colorSpace = m_param->internalCsp;
+                    pic_out[sLayer].frameData.tLayer = outFrame->m_tempLayer;
+                    pic_out[sLayer].layerID = sLayer;
+                    frameData = &(pic_out[sLayer].frameData);
+
+                    pic_out[sLayer].pts = outFrame->m_pts;
+                    pic_out[sLayer].dts = outFrame->m_dts;
+                    pic_out[sLayer].reorderedPts = outFrame->m_reorderedPts;
+                    pic_out[sLayer].sliceType = outFrame->m_lowres.sliceType;
+                    pic_out[sLayer].planes[0] = recpic->m_picOrg[0];
+                    pic_out[sLayer].stride[0] = (int)(recpic->m_stride * sizeof(pixel));
                     if (m_param->internalCsp != X265_CSP_I400)
                     {
-                        pic_out[sLayer]->planes[1] = recpic->m_picOrg[1];
-                        pic_out[sLayer]->stride[1] = (int)(recpic->m_strideC * sizeof(pixel));
-                        pic_out[sLayer]->planes[2] = recpic->m_picOrg[2];
-                        pic_out[sLayer]->stride[2] = (int)(recpic->m_strideC * sizeof(pixel));
+                        pic_out[sLayer].planes[1] = recpic->m_picOrg[1];
+                        pic_out[sLayer].stride[1] = (int)(recpic->m_strideC * sizeof(pixel));
+                        pic_out[sLayer].planes[2] = recpic->m_picOrg[2];
+                        pic_out[sLayer].stride[2] = (int)(recpic->m_strideC * sizeof(pixel));
                     }
 
-                    /* Dump analysis data from pic_out[sLayer] to file in save mode and free */
+                    /* Dump analysis data from pic_out to file in save mode and free */
                     if (m_param->analysisSave)
                     {
-                        pic_out[sLayer]->analysisData.poc = pic_out[sLayer]->poc;
-                        pic_out[sLayer]->analysisData.sliceType = pic_out[sLayer]->sliceType;
-                        pic_out[sLayer]->analysisData.bScenecut = outFrame->m_lowres.bScenecut;
-                        pic_out[sLayer]->analysisData.satdCost = outFrame->m_lowres.satdCost;
-                        pic_out[sLayer]->analysisData.numCUsInFrame = outFrame->m_analysisData.numCUsInFrame;
-                        pic_out[sLayer]->analysisData.numPartitions = outFrame->m_analysisData.numPartitions;
-                        pic_out[sLayer]->analysisData.wt = outFrame->m_analysisData.wt;
-                        pic_out[sLayer]->analysisData.interData = outFrame->m_analysisData.interData;
-                        pic_out[sLayer]->analysisData.intraData = outFrame->m_analysisData.intraData;
-                        pic_out[sLayer]->analysisData.distortionData = outFrame->m_analysisData.distortionData;
-                        pic_out[sLayer]->analysisData.modeFlag[0] = outFrame->m_analysisData.modeFlag[0];
-                        pic_out[sLayer]->analysisData.modeFlag[1] = outFrame->m_analysisData.modeFlag[1];
+                        pic_out[sLayer].analysisData.poc = pic_out[sLayer].poc;
+                        pic_out[sLayer].analysisData.sliceType = pic_out[sLayer].sliceType;
+                        pic_out[sLayer].analysisData.bScenecut = outFrame->m_lowres.bScenecut;
+                        pic_out[sLayer].analysisData.satdCost = outFrame->m_lowres.satdCost;
+                        pic_out[sLayer].analysisData.numCUsInFrame = outFrame->m_analysisData.numCUsInFrame;
+                        pic_out[sLayer].analysisData.numPartitions = outFrame->m_analysisData.numPartitions;
+                        pic_out[sLayer].analysisData.wt = outFrame->m_analysisData.wt;
+                        pic_out[sLayer].analysisData.interData = outFrame->m_analysisData.interData;
+                        pic_out[sLayer].analysisData.intraData = outFrame->m_analysisData.intraData;
+                        pic_out[sLayer].analysisData.distortionData = outFrame->m_analysisData.distortionData;
+                        pic_out[sLayer].analysisData.modeFlag[0] = outFrame->m_analysisData.modeFlag[0];
+                        pic_out[sLayer].analysisData.modeFlag[1] = outFrame->m_analysisData.modeFlag[1];
                         if (m_param->bDisableLookahead)
                         {
                             int factor = 1;
                             if (m_param->scaleFactor)
                                 factor = m_param->scaleFactor * 2;
-                            pic_out[sLayer]->analysisData.numCuInHeight = outFrame->m_analysisData.numCuInHeight;
-                            pic_out[sLayer]->analysisData.lookahead.dts = outFrame->m_dts;
-                            pic_out[sLayer]->analysisData.lookahead.reorderedPts = outFrame->m_reorderedPts;
-                            pic_out[sLayer]->analysisData.satdCost *= factor;
-                            pic_out[sLayer]->analysisData.lookahead.keyframe = outFrame->m_lowres.bKeyframe;
-                            pic_out[sLayer]->analysisData.lookahead.lastMiniGopBFrame = outFrame->m_lowres.bLastMiniGopBFrame;
+                            pic_out[sLayer].analysisData.numCuInHeight = outFrame->m_analysisData.numCuInHeight;
+                            pic_out[sLayer].analysisData.lookahead.dts = outFrame->m_dts;
+                            pic_out[sLayer].analysisData.lookahead.reorderedPts = outFrame->m_reorderedPts;
+                            pic_out[sLayer].analysisData.satdCost *= factor;
+                            pic_out[sLayer].analysisData.lookahead.keyframe = outFrame->m_lowres.bKeyframe;
+                            pic_out[sLayer].analysisData.lookahead.lastMiniGopBFrame = outFrame->m_lowres.bLastMiniGopBFrame;
                             if (m_rateControl->m_isVbv)
                             {
                                 int vbvCount = m_param->lookaheadDepth + m_param->bframes + 2;
                                 for (int index = 0; index < vbvCount; index++)
                                 {
-                                    pic_out[sLayer]->analysisData.lookahead.plannedSatd[index] = outFrame->m_lowres.plannedSatd[index];
-                                    pic_out[sLayer]->analysisData.lookahead.plannedType[index] = outFrame->m_lowres.plannedType[index];
+                                    pic_out[sLayer].analysisData.lookahead.plannedSatd[index] = outFrame->m_lowres.plannedSatd[index];
+                                    pic_out[sLayer].analysisData.lookahead.plannedType[index] = outFrame->m_lowres.plannedType[index];
                                 }
-                                for (uint32_t index = 0; index < pic_out[sLayer]->analysisData.numCuInHeight; index++)
+                                for (uint32_t index = 0; index < pic_out[sLayer].analysisData.numCuInHeight; index++)
                                 {
                                     outFrame->m_analysisData.lookahead.intraSatdForVbv[index] = outFrame->m_encData->m_rowStat[index].intraSatdForVbv;
                                     outFrame->m_analysisData.lookahead.satdForVbv[index] = outFrame->m_encData->m_rowStat[index].satdForVbv;
                                 }
-                                pic_out[sLayer]->analysisData.lookahead.intraSatdForVbv = outFrame->m_analysisData.lookahead.intraSatdForVbv;
-                                pic_out[sLayer]->analysisData.lookahead.satdForVbv = outFrame->m_analysisData.lookahead.satdForVbv;
-                                for (uint32_t index = 0; index < pic_out[sLayer]->analysisData.numCUsInFrame; index++)
+                                pic_out[sLayer].analysisData.lookahead.intraSatdForVbv = outFrame->m_analysisData.lookahead.intraSatdForVbv;
+                                pic_out[sLayer].analysisData.lookahead.satdForVbv = outFrame->m_analysisData.lookahead.satdForVbv;
+                                for (uint32_t index = 0; index < pic_out[sLayer].analysisData.numCUsInFrame; index++)
                                 {
                                     outFrame->m_analysisData.lookahead.intraVbvCost[index] = outFrame->m_encData->m_cuStat[index].intraVbvCost;
                                     outFrame->m_analysisData.lookahead.vbvCost[index] = outFrame->m_encData->m_cuStat[index].vbvCost;
                                 }
-                                pic_out[sLayer]->analysisData.lookahead.intraVbvCost = outFrame->m_analysisData.lookahead.intraVbvCost;
-                                pic_out[sLayer]->analysisData.lookahead.vbvCost = outFrame->m_analysisData.lookahead.vbvCost;
+                                pic_out[sLayer].analysisData.lookahead.intraVbvCost = outFrame->m_analysisData.lookahead.intraVbvCost;
+                                pic_out[sLayer].analysisData.lookahead.vbvCost = outFrame->m_analysisData.lookahead.vbvCost;
                             }
                         }
-                        writeAnalysisFile(&pic_out[sLayer]->analysisData, *outFrame->m_encData);
-                        pic_out[sLayer]->analysisData.saveParam = pic_out[sLayer]->analysisData.saveParam;
+                        writeAnalysisFile(&pic_out[sLayer].analysisData, *outFrame->m_encData);
+                        pic_out[sLayer].analysisData.saveParam = pic_out[sLayer].analysisData.saveParam;
                         if (m_param->bUseAnalysisFile)
-                            x265_free_analysis_data(m_param, &pic_out[sLayer]->analysisData);
+                            x265_free_analysis_data(m_param, &pic_out[sLayer].analysisData);
                     }
                 }
                 if (m_param->rc.bStatWrite && (m_param->analysisMultiPassRefine || m_param->analysisMultiPassDistortion))
                 {
-                    if (pic_out[sLayer])
+                    if (pic_out && (&pic_out[sLayer]))
                     {
-                        pic_out[sLayer]->analysisData.poc = pic_out[sLayer]->poc;
-                        pic_out[sLayer]->analysisData.interData = outFrame->m_analysisData.interData;
-                        pic_out[sLayer]->analysisData.intraData = outFrame->m_analysisData.intraData;
-                        pic_out[sLayer]->analysisData.distortionData = outFrame->m_analysisData.distortionData;
+                        pic_out[sLayer].analysisData.poc = pic_out[sLayer].poc;
+                        pic_out[sLayer].analysisData.interData = outFrame->m_analysisData.interData;
+                        pic_out[sLayer].analysisData.intraData = outFrame->m_analysisData.intraData;
+                        pic_out[sLayer].analysisData.distortionData = outFrame->m_analysisData.distortionData;
                     }
                     writeAnalysisFileRefine(&outFrame->m_analysisData, *outFrame->m_encData);
                 }
@@ -2123,11 +2123,11 @@ int Encoder::encode(const x265_picture* pic_in, x265_picture** pic_out)
                     finishFrameStats(outFrame, curEncoder, frameData, m_pocLast, sLayer);
                 if (m_param->analysisSave)
                 {
-                    pic_out[sLayer]->analysisData.frameBits = frameData->bits;
+                    pic_out[sLayer].analysisData.frameBits = frameData->bits;
                     if (!slice->isIntra())
                     {
                         for (int ref = 0; ref < MAX_NUM_REF; ref++)
-                            pic_out[sLayer]->analysisData.list0POC[ref] = frameData->list0POC[ref];
+                            pic_out[sLayer].analysisData.list0POC[ref] = frameData->list0POC[ref];
 
                         double totalIntraPercent = 0;
 
@@ -2138,12 +2138,12 @@ int Encoder::encode(const x265_picture* pic_in, x265_picture** pic_out)
 
                         for (uint32_t depth = 0; depth < m_param->maxCUDepth; depth++)
                             totalIntraPercent += frameData->puStats.percentIntraPu[depth];
-                        pic_out[sLayer]->analysisData.totalIntraPercent = totalIntraPercent;
+                        pic_out[sLayer].analysisData.totalIntraPercent = totalIntraPercent;
 
                         if (!slice->isInterP())
                         {
                             for (int ref = 0; ref < MAX_NUM_REF; ref++)
-                                pic_out[sLayer]->analysisData.list1POC[ref] = frameData->list1POC[ref];
+                                pic_out[sLayer].analysisData.list1POC[ref] = frameData->list1POC[ref];
                         }
                     }
                 }
@@ -2152,10 +2152,10 @@ int Encoder::encode(const x265_picture* pic_in, x265_picture** pic_out)
                 if (m_param->rc.bStatWrite)
                     if (m_rateControl->writeRateControlFrameStats(outFrame, &curEncoder->m_rce))
                         m_aborted = true;
-                if (pic_out[sLayer])
+                if (pic_out && (&pic_out[sLayer]))
                 {
                     /* m_rcData is allocated for every frame */
-                    pic_out[sLayer]->rcData = outFrame->m_rcData;
+                    pic_out[sLayer].rcData = outFrame->m_rcData;
                     outFrame->m_rcData->qpaRc = outFrame->m_encData->m_avgQpRc;
                     outFrame->m_rcData->qRceq = curEncoder->m_rce.qRceq;
                     outFrame->m_rcData->qpNoVbv = curEncoder->m_rce.qpNoVbv;
@@ -2186,7 +2186,7 @@ int Encoder::encode(const x265_picture* pic_in, x265_picture** pic_out)
                 }
 
                 /* Allow this frame to be recycled if no frame encoders are using it for reference */
-                if (!pic_out[sLayer])
+                if (!pic_out || !(&pic_out[sLayer]))
                 {
                     ATOMIC_DEC(&outFrame->m_countRefEncoders);
                     m_dpb->recycleUnreferenced();
@@ -3118,7 +3118,7 @@ void Encoder::finishFrameStats(Frame* curFrame, FrameEncoder *curEncoder, x265_f
         m_analyzeAll[layer].addPsnr(psnrY, psnrU, psnrV);
 
     double ssim = 0.0;
-    if (m_param->bEnableSsim && curEncoder->m_ssimCnt)
+    if (m_param->bEnableSsim && curEncoder->m_ssimCnt[layer])
     {
         ssim = curEncoder->m_ssim[layer] / curEncoder->m_ssimCnt[layer];
         m_analyzeAll[layer].addSsim(ssim);
diff --git a/source/encoder/encoder.h b/source/encoder/encoder.h
index 1dbb41596..e5020c1dc 100644
--- a/source/encoder/encoder.h
+++ b/source/encoder/encoder.h
@@ -300,7 +300,7 @@ public:
     void stopJobs();
     void destroy();
 
-    int encode(const x265_picture* pic, x265_picture **pic_out);
+    int encode(const x265_picture* pic, x265_picture *pic_out);
 
     int reconfigureParam(x265_param* encParam, x265_param* param);
 
diff --git a/source/encoder/frameencoder.cpp b/source/encoder/frameencoder.cpp
index 6f930c527..deb478a0f 100644
--- a/source/encoder/frameencoder.cpp
+++ b/source/encoder/frameencoder.cpp
@@ -1475,7 +1475,7 @@ void FrameEncoder::encodeSlice(uint32_t sliceAddr, int layer)
 void FrameEncoder::processRow(int row, int threadId, int layer)
 {
     int64_t startTime = x265_mdate();
-    if (ATOMIC_INC(&m_activeWorkerCount) == 1 && m_stallStartTime)
+    if (ATOMIC_INC(&m_activeWorkerCount) == 1 && m_stallStartTime[layer])
         m_totalNoWorkerTime[layer] += x265_mdate() - m_stallStartTime[layer];
 
     const uint32_t realRow = m_idx_to_row[row >> 1];
diff --git a/source/x265.h b/source/x265.h
index 897bc5ad5..aba7b12bf 100644
--- a/source/x265.h
+++ b/source/x265.h
@@ -2495,7 +2495,7 @@ int x265_encoder_headers(x265_encoder *, x265_nal **pp_nal, uint32_t *pi_nal);
  *      the payloads of all output NALs are guaranteed to be sequential in memory.
  *      To flush the encoder and retrieve delayed output pictures, pass pic_in as NULL.
  *      Once flushing has begun, all subsequent calls must pass pic_in as NULL. */
-int x265_encoder_encode(x265_encoder *encoder, x265_nal **pp_nal, uint32_t *pi_nal, x265_picture *pic_in, x265_picture **pic_out);
+int x265_encoder_encode(x265_encoder* encoder, x265_nal** pp_nal, uint32_t* pi_nal, x265_picture* pic_in, x265_picture* pic_out);
 
 /*
 x265_configure_vbv_end:
@@ -2656,7 +2656,7 @@ typedef struct x265_api
     int           (*encoder_reconfig_zone)(x265_encoder*, x265_zone*);
     int           (*encoder_headers)(x265_encoder*, x265_nal**, uint32_t*);
     void          (*configure_vbv_end)(x265_encoder*, x265_picture*, double );
-    int           (*encoder_encode)(x265_encoder*, x265_nal**, uint32_t*, x265_picture*, x265_picture**);
+    int           (*encoder_encode)(x265_encoder*, x265_nal**, uint32_t*, x265_picture*, x265_picture*);
     void          (*encoder_get_stats)(x265_encoder*, x265_stats*, uint32_t);
     void          (*encoder_log)(x265_encoder*, int, char**);
     void          (*encoder_close)(x265_encoder*);
-- 
2.46.2

