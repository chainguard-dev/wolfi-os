Patch adapted from github.com/apache/commons-crypto/pull/200
---
diff --git a/Makefile b/Makefile
index a839b95..cc1205a 100644
--- a/Makefile
+++ b/Makefile
@@ -19,6 +19,7 @@ include Makefile.common
 
 COMMONS_CRYPTO_OUT:=$(TARGET)/$(commons-crypto)-$(os_arch)
 COMMONS_CRYPTO_OBJ:=$(addprefix $(COMMONS_CRYPTO_OUT)/,OpenSslCryptoRandomNative.o OpenSslNative.o OpenSslInfoNative.o DynamicLoader.o)
+COMMONS_CRYPTO_OSSL3_OBJ:=$(addprefix $(COMMONS_CRYPTO_OUT)/,OpenSslCryptoRandomNative.o OpenSsl3Native.o OpenSslInfoNative.o DynamicLoader.o)
 
 # Shorthand for local dependencies
 CRYPTO_H:=$(SRC_NATIVE)/org/apache/commons/crypto/org_apache_commons_crypto.h lib/include/config.h
@@ -38,12 +39,16 @@ endif
 
 NATIVE_TARGET_DIR:=$(TARGET)/classes/org/apache/commons/crypto/native/$(OS_NAME)/$(OS_ARCH)
 NATIVE_DLL:=$(NATIVE_TARGET_DIR)/$(LIBNAME)
+NATIVE_OSSL3_DLL:=$(NATIVE_TARGET_DIR)/$(LIBNAME_OSSL3)
 
-all: $(NATIVE_DLL)
+all: $(NATIVE_DLL) $(NATIVE_OSSL3_DLL)
 
 #$(TARGET)/jni-classes/org/apache/commons/crypto/cipher/OpenSslNative.h: $(TARGET)/classes/org/apache/commons/crypto/cipher/OpenSslNative.class
 #	$(JAVAH) -force -classpath $(TARGET)/classes -o $@ org.apache.commons.crypto.cipher.OpenSslNative
 
+#$(TARGET)/jni-classes/org/apache/commons/crypto/cipher/OpenSsl3Native.h: $(TARGET)/classes/org/apache/commons/crypto/cipher/OpenSsl3Native.class
+#	$(JAVAH) -force -classpath $(TARGET)/classes -o $@ org.apache.commons.crypto.cipher.OpenSsl3Native
+
 #$(TARGET)/jni-classes/org/apache/commons/crypto/random/OpenSslCryptoRandomNative.h: $(TARGET)/classes/org/apache/commons/crypto/random/OpenSslCryptoRandomNative.class
 #	$(JAVAH) -force -classpath $(TARGET)/classes -o $@ org.apache.commons.crypto.random.OpenSslCryptoRandomNative
 
@@ -54,6 +59,10 @@ $(COMMONS_CRYPTO_OUT)/OpenSslNative.o : $(SRC_NATIVE)/org/apache/commons/crypto/
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $< -o $@
 
+$(COMMONS_CRYPTO_OUT)/OpenSsl3Native.o : $(SRC_NATIVE)/org/apache/commons/crypto/cipher/OpenSsl3Native.c $(CRYPTO_H) $(TARGET)/jni-classes/org_apache_commons_crypto_cipher_OpenSsl3Native.h
+	@mkdir -p $(@D)
+	$(CC) $(CFLAGS) -c $< -o $@
+
 $(COMMONS_CRYPTO_OUT)/OpenSslCryptoRandomNative.o : $(SRC_NATIVE)/org/apache/commons/crypto/random/OpenSslCryptoRandomNative.c $(CRYPTO_H) $(CRYPTO_RANDOM_H) $(TARGET)/jni-classes/org_apache_commons_crypto_random_OpenSslCryptoRandomNative.h
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $< -o $@
@@ -70,16 +79,24 @@ $(COMMONS_CRYPTO_OUT)/$(LIBNAME): $(COMMONS_CRYPTO_OBJ)
 	$(CXX) $(CXXFLAGS) -o $@ $+ $(LINKFLAGS)
 	$(STRIP) $@
 
+$(COMMONS_CRYPTO_OUT)/$(LIBNAME_OSSL3): $(COMMONS_CRYPTO_OSSL3_OBJ)
+	$(CXX) $(CXXFLAGS) -o $@ $+ $(LINKFLAGS)
+	$(STRIP) $@
+
 clean:
 	$(DELTREE) $(subst /,$(FSEP),$(TARGET)/jni-classes)
 	$(DELTREE) $(subst /,$(FSEP),$(COMMONS_CRYPTO_OUT))
 
-native: $(NATIVE_DLL)
+native: $(NATIVE_DLL) $(NATIVE_OSSL3_DLL)
 
 $(NATIVE_DLL): $(COMMONS_CRYPTO_OUT)/$(LIBNAME)
 	@mkdir -p $(@D)
 	cp $< $@
 
+$(NATIVE_OSSL3_DLL): $(COMMONS_CRYPTO_OUT)/$(LIBNAME_OSSL3)
+	@mkdir -p $(@D)
+	cp $< $@
+
 win32:
 	$(MAKE) native CROSS_PREFIX=i686-w64-mingw32- OS_NAME=Windows OS_ARCH=x86
 
diff --git a/Makefile.common b/Makefile.common
index e4e4043..16e7e9f 100644
--- a/Makefile.common
+++ b/Makefile.common
@@ -65,6 +65,14 @@ os_folder := $(shell echo $(OS_NAME) | tr A-Z a-z)
 # cross-compilation toolchain prefix (e.g. "arm-linux-gnueabi-")
 CROSS_PREFIX :=
 
+Default_CC            := $(CROSS_PREFIX)gcc
+Default_CXX           := $(CROSS_PREFIX)g++
+Default_STRIP         := $(CROSS_PREFIX)strip
+Default_CFLAGS        := -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden
+Default_CXXFLAGS      := -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden
+Default_LINKFLAGS     := -shared -static
+Default_LIBNAME       := libcommons-crypto.so
+Default_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Default_CC            := $(CROSS_PREFIX)gcc
 Default_CXX           := $(CROSS_PREFIX)g++
 Default_STRIP         := $(CROSS_PREFIX)strip
@@ -75,6 +83,14 @@ Default_LIBNAME       := libcommons-crypto.so
 Default_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Default_COMMONS_CRYPTO_FLAGS :=
 
+Linux-x86_CC            := $(CROSS_PREFIX)gcc
+Linux-x86_CXX           := $(CROSS_PREFIX)g++
+Linux-x86_STRIP         := $(CROSS_PREFIX)strip
+Linux-x86_CXXFLAGS      := -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden -m32
+Linux-x86_CFLAGS        := -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden -m32
+Linux-x86_LINKFLAGS     := -shared -static-libgcc -static-libstdc++
+Linux-x86_LIBNAME       := libcommons-crypto.so
+Linux-x86_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-x86_CC            := $(CROSS_PREFIX)gcc
 Linux-x86_CXX           := $(CROSS_PREFIX)g++
 Linux-x86_STRIP         := $(CROSS_PREFIX)strip
@@ -85,6 +101,14 @@ Linux-x86_LIBNAME       := libcommons-crypto.so
 Linux-x86_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-x86_COMMONS_CRYPTO_FLAGS:=
 
+Linux-x86_64_CC            := $(CROSS_PREFIX)gcc
+Linux-x86_64_CXX           := $(CROSS_PREFIX)g++
+Linux-x86_64_STRIP         := $(CROSS_PREFIX)strip
+Linux-x86_64_CXXFLAGS      := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -m64 -Wall -Werror
+Linux-x86_64_CFLAGS        := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -m64 -Wall -Werror
+Linux-x86_64_LINKFLAGS     := -shared -static-libgcc
+Linux-x86_64_LIBNAME       := libcommons-crypto.so
+Linux-x86_64_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-x86_64_CC            := $(CROSS_PREFIX)gcc
 Linux-x86_64_CXX           := $(CROSS_PREFIX)g++
 Linux-x86_64_STRIP         := $(CROSS_PREFIX)strip
@@ -95,6 +119,14 @@ Linux-x86_64_LIBNAME       := libcommons-crypto.so
 Linux-x86_64_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-x86_64_COMMONS_CRYPTO_FLAGS  :=
 
+Linux-ppc_CC            := gcc
+Linux-ppc_CXX           := g++
+Linux-ppc_STRIP         := strip
+Linux-ppc_CXXFLAGS      := -DHAVE_CONFIG_H -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -m32
+Linux-ppc_CFLAGS        := -DHAVE_CONFIG_H -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -m32
+Linux-ppc_LINKFLAGS     := -shared -static-libgcc -static-libstdc++
+Linux-ppc_LIBNAME       := libcommons-crypto.so
+Linux-ppc_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-ppc_CC            := gcc
 Linux-ppc_CXX           := g++
 Linux-ppc_STRIP         := strip
@@ -105,6 +137,14 @@ Linux-ppc_LIBNAME       := libcommons-crypto.so
 Linux-ppc_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-ppc_COMMONS_CRYPTO_FLAGS  :=
 
+Linux-ppc64_CC            := gcc
+Linux-ppc64_CXX           := g++
+Linux-ppc64_STRIP         := strip
+Linux-ppc64_CXXFLAGS      := -DHAVE_CONFIG_H -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -m64
+Linux-ppc64_CFLAGS        := -DHAVE_CONFIG_H -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -m64
+Linux-ppc64_LINKFLAGS     := -shared -static-libgcc -static-libstdc++
+Linux-ppc64_LIBNAME       := libcommons-crypto.so
+Linux-ppc64_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-ppc64_CC            := gcc
 Linux-ppc64_CXX           := g++
 Linux-ppc64_STRIP         := strip
@@ -115,15 +155,23 @@ Linux-ppc64_LIBNAME       := libcommons-crypto.so
 Linux-ppc64_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-ppc64_COMMONS_CRYPTO_FLAGS  :=
 
-AIX-ppc64_CC        := gcc
-AIX-ppc64_CXX       := g++
-AIX-ppc64_STRIP     := strip -X64
-AIX-ppc64_LIBNAME   := libcommons-crypto.a
+AIX-ppc64_CC           := gcc
+AIX-ppc64_CXX          := g++
+AIX-ppc64_STRIP        := strip -X64
+AIX-ppc64_LIBNAME      := libcommons-crypto.a
 AIX-ppc64_CXXFLAGS     := -DHAVE_CONFIG_H -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -m64
 AIX-ppc64_CFLAGS       := -DHAVE_CONFIG_H -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -m64
 AIX-ppc64_LINKFLAGS := -shared -static-libgcc -static-libstdc++ -lcrypt
 AIX-ppc64_COMMONS_CRYPTO_FLAGS  :=
 
+SunOS-x86_CC            := gcc
+SunOS-x86_CXX           := g++
+SunOS-x86_STRIP         := strip
+SunOS-x86_CFLAGS        := -include lib/inc_linux/jni_md.h -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden
+SunOS-x86_CXXFLAGS      := -include lib/inc_linux/jni_md.h -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden
+SunOS-x86_LINKFLAGS     := -shared -static-libgcc -static-libstdc++
+SunOS-x86_LIBNAME       := libcommons-crypto.so
+SunOS-x86_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 SunOS-x86_CC            := gcc
 SunOS-x86_CXX           := g++
 SunOS-x86_STRIP         := strip
@@ -134,13 +182,13 @@ SunOS-x86_LIBNAME       := libcommons-crypto.so
 SunOS-x86_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 SunOS-x86_COMMONS_CRYPTO_FLAGS  :=
 
-SunOS-sparc_CC        := gcc
-SunOS-sparc_CXX       := g++
-SunOS-sparc_STRIP     := strip
-SunOS-sparc_CFLAGS    := -include lib/inc_linux/jni_md.h -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden
-SunOS-sparc_CXXFLAGS  := -include lib/inc_linux/jni_md.h -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden
-SunOS-sparc_LINKFLAGS := -shared -static-libgcc -static-libstdc++
-SunOS-sparc_LIBNAME   := libcommons-crypto.so
+SunOS-sparc_CC            := gcc
+SunOS-sparc_CXX           := g++
+SunOS-sparc_STRIP         := strip
+SunOS-sparc_CFLAGS        := -include lib/inc_linux/jni_md.h -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden
+SunOS-sparc_CXXFLAGS      := -include lib/inc_linux/jni_md.h -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden
+SunOS-sparc_LINKFLAGS     := -shared -static-libgcc -static-libstdc++
+SunOS-sparc_LIBNAME       := libcommons-crypto.so
 SunOS-sparc_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 SunOS-sparc_COMMONS_CRYPTO_FLAGS  :=
 
@@ -152,6 +200,7 @@ SunOS-x86_64_CXXFLAGS  := -include lib/inc_linux/jni_md.h -I"$(JAVA_HOME)/includ
 SunOS-x86_64_LINKFLAGS := -shared -static-libgcc -static-libstdc++
 SunOS-x86_64_LIBNAME   := libcommons-crypto.so
 SunOS-x86_64_LIBNAME_OSSL3  := libcommons-crypto-ossl3.so
+SunOS-x86_64_LIBNAME_OSSL3  := libcommons-crypto-ossl3.so
 SunOS-x86_64_COMMONS_CRYPTO_FLAGS  :=
 
 # '-include lib/inc_linux/jni_md.h' is used to force the use of our version,
@@ -159,102 +208,103 @@ SunOS-x86_64_COMMONS_CRYPTO_FLAGS  :=
 # jni_md.h in same directory as jni.h, the include path is ignored when
 # jni_md.h is included from jni.h
 
-Linux-arm_CC        := $(CROSS_PREFIX)gcc
-Linux-arm_CXX       := $(CROSS_PREFIX)g++
-Linux-arm_STRIP     := $(CROSS_PREFIX)strip
-Linux-arm_CFLAGS    := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden -mfloat-abi=softfp
-Linux-arm_CXXFLAGS  := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden -mfloat-abi=softfp
-Linux-arm_LINKFLAGS := -shared -static-libgcc
-Linux-arm_LIBNAME   := libcommons-crypto.so
+Linux-arm_CC            := $(CROSS_PREFIX)gcc
+Linux-arm_CXX           := $(CROSS_PREFIX)g++
+Linux-arm_STRIP         := $(CROSS_PREFIX)strip
+Linux-arm_CFLAGS        := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden -mfloat-abi=softfp
+Linux-arm_CXXFLAGS      := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden -mfloat-abi=softfp
+Linux-arm_LINKFLAGS     := -shared -static-libgcc
+Linux-arm_LIBNAME       := libcommons-crypto.so
 Linux-arm_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-arm_COMMONS_CRYPTO_FLAGS:=
 
-Linux-armhf_CC        := $(CROSS_PREFIX)gcc
-Linux-armhf_CXX       := $(CROSS_PREFIX)g++
-Linux-armhf_STRIP     := $(CROSS_PREFIX)strip
-Linux-armhf_CFLAGS    := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden -mfloat-abi=hard
-Linux-armhf_CXXFLAGS  := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden -mfloat-abi=hard
-Linux-armhf_LINKFLAGS := -shared -static-libgcc
-Linux-armhf_LIBNAME   := libcommons-crypto.so
+Linux-armhf_CC            := $(CROSS_PREFIX)gcc
+Linux-armhf_CXX           := $(CROSS_PREFIX)g++
+Linux-armhf_STRIP         := $(CROSS_PREFIX)strip
+Linux-armhf_CFLAGS        := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden -mfloat-abi=hard
+Linux-armhf_CXXFLAGS      := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -O2 -fPIC -fvisibility=hidden -mfloat-abi=hard
+Linux-armhf_LINKFLAGS     := -shared -static-libgcc
+Linux-armhf_LIBNAME       := libcommons-crypto.so
 Linux-armhf_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-armhf_COMMONS_CRYPTO_FLAGS:=
 
-Linux-aarch64_CC        := $(CROSS_PREFIX)gcc
-Linux-aarch64_CXX       := $(CROSS_PREFIX)g++
-Linux-aarch64_STRIP     := $(CROSS_PREFIX)strip
-Linux-aarch64_CXXFLAGS  := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -Wall -Werror
-Linux-aarch64_CFLAGS    := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -Wall -Werror
-Linux-aarch64_LINKFLAGS := -shared -static-libgcc
-Linux-aarch64_LIBNAME   := libcommons-crypto.so
+Linux-aarch64_CC            := $(CROSS_PREFIX)gcc
+Linux-aarch64_CXX           := $(CROSS_PREFIX)g++
+Linux-aarch64_STRIP         := $(CROSS_PREFIX)strip
+Linux-aarch64_CXXFLAGS      := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -Wall -Werror
+Linux-aarch64_CFLAGS        := -Ilib/inc_linux -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden -Wall -Werror
+Linux-aarch64_LINKFLAGS     := -shared -static-libgcc
+Linux-aarch64_LIBNAME       := libcommons-crypto.so
 Linux-aarch64_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 Linux-aarch64_COMMONS_CRYPTO_FLAGS  :=
 
-Mac-x86_CC        := gcc -arch i386
-Mac-x86_CXX       := g++ -arch i386
-Mac-x86_STRIP     := strip -x
-Mac-x86_CFLAGS    := -Ilib/inc_mac -I"$(JAVA_HOME)/include" -O2 -fPIC -mmacosx-version-min=10.4 -fvisibility=hidden -I/usr/local/include -I/usr/local/opt/openssl/include
-Mac-x86_CXXFLAGS  := -Ilib/inc_mac -I"$(JAVA_HOME)/include" -O2 -fPIC -mmacosx-version-min=10.4 -fvisibility=hidden -I/usr/local/include -I/usr/local/opt/openssl/include
-Mac-x86_LINKFLAGS := -dynamiclib -static-libgcc -L/usr/local/lib
-Mac-x86_LIBNAME   := libcommons-crypto.jnilib
+Mac-x86_CC            := gcc -arch i386
+Mac-x86_CXX           := g++ -arch i386
+Mac-x86_STRIP         := strip -x
+Mac-x86_CFLAGS        := -Ilib/inc_mac -I"$(JAVA_HOME)/include" -O2 -fPIC -mmacosx-version-min=10.4 -fvisibility=hidden -I/usr/local/include -I/usr/local/opt/openssl/include
+Mac-x86_CXXFLAGS      := -Ilib/inc_mac -I"$(JAVA_HOME)/include" -O2 -fPIC -mmacosx-version-min=10.4 -fvisibility=hidden -I/usr/local/include -I/usr/local/opt/openssl/include
+Mac-x86_LINKFLAGS     := -dynamiclib -static-libgcc -L/usr/local/lib
+Mac-x86_LIBNAME       := libcommons-crypto.jnilib
 Mac-x86_LIBNAME_OSSL3 := libcommons-crypto-ossl3.jnilib
 Mac-x86_COMMONS_CRYPTO_FLAGS  :=
 
-Mac-x86_64_CC        := gcc -arch $(OS_ARCH)
-Mac-x86_64_CXX       := gcc -arch $(OS_ARCH)
-Mac-x86_64_STRIP     := strip -x
-Mac-x86_64_CFLAGS    := -Ilib/inc_mac -I"$(JAVA_HOME)/include" -O2 -fPIC -mmacosx-version-min=10.7 -fvisibility=hidden -I/usr/local/include -I/usr/local/opt/openssl/include
-Mac-x86_64_CXXFLAGS  := -Ilib/inc_mac -I"$(JAVA_HOME)/include" -O2 -fPIC -mmacosx-version-min=10.7 -fvisibility=hidden -I/usr/local/include -I/usr/local/opt/openssl/include
-Mac-x86_64_LINKFLAGS := -dynamiclib -L/usr/local/lib
-Mac-x86_64_LIBNAME   := libcommons-crypto.jnilib
+Mac-x86_64_CC            := gcc -arch $(OS_ARCH)
+Mac-x86_64_CXX           := gcc -arch $(OS_ARCH)
+Mac-x86_64_STRIP         := strip -x
+Mac-x86_64_CFLAGS        := -Ilib/inc_mac -I"$(JAVA_HOME)/include" -O2 -fPIC -mmacosx-version-min=10.7 -fvisibility=hidden -I/usr/local/include -I/usr/local/opt/openssl/include
+Mac-x86_64_CXXFLAGS      := -Ilib/inc_mac -I"$(JAVA_HOME)/include" -O2 -fPIC -mmacosx-version-min=10.7 -fvisibility=hidden -I/usr/local/include -I/usr/local/opt/openssl/include
+Mac-x86_64_LINKFLAGS     := -dynamiclib -L/usr/local/lib
+Mac-x86_64_LIBNAME       := libcommons-crypto.jnilib
+Mac-x86_64_LIBNAME_OSSL3 := libcommons-crypto-ossl3.jnilib
 Mac-x86_64_LIBNAME_OSSL3 := libcommons-crypto-ossl3.jnilib
 Mac-x86_64_COMMONS_CRYPTO_FLAGS  :=
 
-FreeBSD-x86_64_CC           := $(CROSS_PREFIX)gcc
-FreeBSD-x86_64_CXX          := $(CROSS_PREFIX)g++
-FreeBSD-x86_64_STRIP        := $(CROSS_PREFIX)strip
-FreeBSD-x86_64_CFLAGS       := -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden
-FreeBSD-x86_64_CXXFLAGS     := -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden
-FreeBSD-x86_64_LINKFLAGS    := -shared -static-libgcc
-FreeBSD-x86_64_LIBNAME      := libcommons-crypto.so
+FreeBSD-x86_64_CC            := $(CROSS_PREFIX)gcc
+FreeBSD-x86_64_CXX           := $(CROSS_PREFIX)g++
+FreeBSD-x86_64_STRIP         := $(CROSS_PREFIX)strip
+FreeBSD-x86_64_CFLAGS        := -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden
+FreeBSD-x86_64_CXXFLAGS      := -I"$(JAVA_HOME)/include" -Ilib/inc_mac -O2 -fPIC -fvisibility=hidden
+FreeBSD-x86_64_LINKFLAGS     := -shared -static-libgcc
+FreeBSD-x86_64_LIBNAME       := libcommons-crypto.so
 FreeBSD-x86_64_LIBNAME_OSSL3 := libcommons-crypto-ossl3.so
 FreeBSD-x86_64_COMMONS_CRYPTO_FLAGS :=
 
-Windows-x86_CC           := $(CROSS_PREFIX)gcc
-Windows-x86_CXX          := $(CROSS_PREFIX)g++
-Windows-x86_STRIP        := $(CROSS_PREFIX)strip
-Windows-x86_CFLAGS       := -I/usr/share/mingw-w64/include -I"$(JAVA_HOME)/include" -I"$(OPENSSL_HOME)/include" -Ilib/inc_win -O2 -fno-inline
-Windows-x86_CXXFLAGS     := -I/usr/share/mingw-w64/include -I"$(JAVA_HOME)/include" -I"$(OPENSSL_HOME)/include" -Ilib/inc_win -O2 -fno-inline
-Windows-x86_LINKFLAGS    := -Wl,--kill-at -shared -static
-Windows-x86_LIBNAME      := commons-crypto.dll
+Windows-x86_CC            := $(CROSS_PREFIX)gcc
+Windows-x86_CXX           := $(CROSS_PREFIX)g++
+Windows-x86_STRIP         := $(CROSS_PREFIX)strip
+Windows-x86_CFLAGS        := -I/usr/share/mingw-w64/include -I"$(JAVA_HOME)/include" -I"$(OPENSSL_HOME)/include" -Ilib/inc_win -O2 -fno-inline
+Windows-x86_CXXFLAGS      := -I/usr/share/mingw-w64/include -I"$(JAVA_HOME)/include" -I"$(OPENSSL_HOME)/include" -Ilib/inc_win -O2 -fno-inline
+Windows-x86_LINKFLAGS     := -Wl,--kill-at -shared -static
+Windows-x86_LIBNAME       := commons-crypto.dll
 Windows-x86_LIBNAME_OSSL3 := commons-crypto-ossl3.dll
 Windows-x86_COMMONS_CRYPTO_FLAGS :=
 
-Windows-x86_64_CC           := $(CROSS_PREFIX)gcc
-Windows-x86_64_CXX          := $(CROSS_PREFIX)g++
-Windows-x86_64_STRIP        := $(CROSS_PREFIX)strip
-Windows-x86_64_CFLAGS       := -I/usr/share/mingw-w64/include -I"$(JAVA_HOME)/include" -I"$(OPENSSL_HOME)/include" -Ilib/inc_win -O2 -fno-inline
-Windows-x86_64_CXXFLAGS     := -I/usr/share/mingw-w64/include -I"$(JAVA_HOME)/include" -I"$(OPENSSL_HOME)/include" -Ilib/inc_win -O2 -fno-inline
-Windows-x86_64_LINKFLAGS    := -Wl,--kill-at -shared -static
-Windows-x86_64_LIBNAME      := commons-crypto.dll
+Windows-x86_64_CC            := $(CROSS_PREFIX)gcc
+Windows-x86_64_CXX           := $(CROSS_PREFIX)g++
+Windows-x86_64_STRIP         := $(CROSS_PREFIX)strip
+Windows-x86_64_CFLAGS        := -I/usr/share/mingw-w64/include -I"$(JAVA_HOME)/include" -I"$(OPENSSL_HOME)/include" -Ilib/inc_win -O2 -fno-inline
+Windows-x86_64_CXXFLAGS      := -I/usr/share/mingw-w64/include -I"$(JAVA_HOME)/include" -I"$(OPENSSL_HOME)/include" -Ilib/inc_win -O2 -fno-inline
+Windows-x86_64_LINKFLAGS     := -Wl,--kill-at -shared -static
+Windows-x86_64_LIBNAME       := commons-crypto.dll
 Windows-x86_64_LIBNAME_OSSL3 := commons-crypto-ossl3.dll
 Windows-x86_64_COMMONS-CRYPTO_FLAGS :=
 
 
-STRIP     := $($(os_arch)_STRIP)
-CC        := $($(os_arch)_CC)
-CXX       := $($(os_arch)_CXX)
-STRIP     := $($(os_arch)_STRIP)
-CFLAGS    := $($(os_arch)_CFLAGS)
-CXXFLAGS  := $($(os_arch)_CXXFLAGS)
-LINKFLAGS := $($(os_arch)_LINKFLAGS)
-LIBNAME   := $($(os_arch)_LIBNAME)
-LIBNAME_OSSL3 := $($(os_arch)_LIBNAME_OSSL3)
+STRIP                := $($(os_arch)_STRIP)
+CC                   := $($(os_arch)_CC)
+CXX                  := $($(os_arch)_CXX)
+STRIP                := $($(os_arch)_STRIP)
+CFLAGS               := $($(os_arch)_CFLAGS)
+CXXFLAGS             := $($(os_arch)_CXXFLAGS)
+LINKFLAGS            := $($(os_arch)_LINKFLAGS)
+LIBNAME              := $($(os_arch)_LIBNAME)
+LIBNAME_OSSL3        := $($(os_arch)_LIBNAME_OSSL3)
 COMMONS-CRYPTO_FLAGS := $($(os_arch)_COMMONS-CRYPTO_FLAGS)
 
 
-CFLAGS := $(CFLAGS) -Ilib/include -I/usr/include -I"$(SRC_NATIVE)/org/apache/commons/crypto/"
+CFLAGS   := $(CFLAGS) -Ilib/include -I/usr/include -I"$(SRC_NATIVE)/org/apache/commons/crypto/"
 CXXFLAGS := $(CXXFLAGS) -Ilib/include  -I/usr/include
 ifneq ($(jni_include),)
-CFLAGS := $(CFLAGS) -I"$(jni_include)" -I"$(TARGET)/jni-classes"
+CFLAGS   := $(CFLAGS) -I"$(jni_include)" -I"$(TARGET)/jni-classes"
 CXXFLAGS := $(CXXFLAGS) -I"$(jni_include)" -I"$(TARGET)/jni-classes"
 endif
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 417fa87..4ecb470 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -78,8 +78,9 @@
       <action                    type="fix" dev="ggregory" due-to="Gary Gregory">Validate return value from OpenSslNativeJna.ENGINE_finish().</action>
       <action                    type="fix" dev="ggregory" due-to="Gary Gregory">Validate return value from OpenSslNativeJna.ENGINE_free().</action>
       <!-- ADD -->
-      <action                    type="fix" dev="ggregory" due-to="Gary Gregory, Dependabot">Add github/codeql-action 2 #159.</action>
-      <action                    type="fix" dev="ggregory" due-to="Gary Gregory, Dependabot">Add AES utility class.</action>
+      <action                    type="add" dev="ggregory" due-to="Gary Gregory, Dependabot">Add github/codeql-action 2 #159.</action>
+      <action                    type="add" dev="ggregory" due-to="Gary Gregory, Dependabot">Add AES utility class.</action>
+      <action                    type="add" dev="ggregory" due-to="Gary Gregory, Dependabot">Add support for OpenSSL 3.0.x.</action>
       <!-- UPDATE -->
       <action                    type="update" dev="ggregory" due-to="Dependabot, Gary Gregory">Bump actions/cache from 2.1.7 to 3.0.9 #150, #184.</action>
       <action                    type="update" dev="ggregory" due-to="Dependabot, Gary Gregory">Bump actions/checkout from 2 to 3.1.0 #149, #187.</action>
diff --git a/src/main/java/org/apache/commons/crypto/Crypto.java b/src/main/java/org/apache/commons/crypto/Crypto.java
index ba2bd80..ed42115 100644
--- a/src/main/java/org/apache/commons/crypto/Crypto.java
+++ b/src/main/java/org/apache/commons/crypto/Crypto.java
@@ -20,7 +20,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
+import java.util.Objects;
 import java.util.Properties;
+import java.util.stream.Stream;
 
 import org.apache.commons.crypto.cipher.CryptoCipher;
 import org.apache.commons.crypto.cipher.CryptoCipherFactory;
@@ -81,6 +83,10 @@ private static Properties getComponentProperties() {
 
     private static boolean quiet = false;
 
+    private static boolean contains(String[] args, String test) {
+        return Stream.of(args).anyMatch(s -> Objects.equals(s, test));
+    }
+
     /**
      * Gets the component version of Apache Commons Crypto.
      * <p>
@@ -150,7 +156,13 @@ public static boolean isNativeCodeLoaded() {
      * @throws Exception if getCryptoRandom or getCryptoCipher get error.
      */
     public static void main(final String[] args) throws Exception {
-        quiet = args.length == 1 && args[0].equals("-q");
+        quiet = contains(args, "-q");
+        if (contains(args, "--openssl1")) {
+            NativeCodeLoader.loadNativeLibrary1();
+        }
+        if (contains(args, "--openssl3")) {
+            NativeCodeLoader.loadNativeLibrary3();
+        }
         info("%s %s", getComponentName(), getComponentVersion());
         if (isNativeCodeLoaded()) {
             info("Native code loaded OK: %s", OpenSslInfoNative.NativeVersion());
diff --git a/src/main/java/org/apache/commons/crypto/NativeCodeLoader.java b/src/main/java/org/apache/commons/crypto/NativeCodeLoader.java
index c450053..0657068 100644
--- a/src/main/java/org/apache/commons/crypto/NativeCodeLoader.java
+++ b/src/main/java/org/apache/commons/crypto/NativeCodeLoader.java
@@ -1,20 +1,20 @@
- /*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 package org.apache.commons.crypto;
 
 import java.io.BufferedInputStream;
@@ -32,45 +32,54 @@
 import org.apache.commons.crypto.utils.Utils;
 
 /**
- * A helper to load the native code i.e. libcommons-crypto.so. This handles the
- * fallback to either the bundled libcommons-crypto-Linux-i386-32.so or the
- * default java implementations where appropriate.
+ * A helper to load the native code i.e. libcommons-crypto.so. This handles the fallback to either the bundled libcommons-crypto-Linux-i386-32.so or the default
+ * java implementations where appropriate.
  */
 final class NativeCodeLoader {
 
     private static final String SIMPLE_NAME = NativeCodeLoader.class.getSimpleName();
 
-    private static final String NATIVE_LIBNAME = "commons-crypto";
+    private static final String NATIVE_LIBNAME_OSSL1 = "commons-crypto";
+    private static final String NATIVE_LIBNAME_OSSL3 = "commons-crypto-ossl3";
 
-    private static final String NATIVE_LIBNAME_ALT = "lib" + NATIVE_LIBNAME + ".jnilib";
+    private static final String NATIVE_LIBNAME_ALT_MAC_OSSL1 = "lib" + NATIVE_LIBNAME_OSSL1 + ".jnilib";
+    private static final String NATIVE_LIBNAME_ALT_MAC_OSSL3 = "lib" + NATIVE_LIBNAME_OSSL3 + ".jnilib";
 
     /**
      * End of file pseudo-character.
      */
     private static final int EOF = -1;
 
-    private static final Throwable libraryLoadingError;
+    private static Throwable libraryLoadingError;
 
-    private static final boolean libraryLoaded;
+    private static boolean libraryLoaded;
 
-    static {
-        debug("%s static init start", SIMPLE_NAME);
-        libraryLoadingError = loadLibrary(); // will be null if loaded OK
-        libraryLoaded = libraryLoadingError == null;
+    private static boolean init;
+
+    private static synchronized void init() {
+        if (init) {
+            return;
+        }
+        init = true;
+        debug("%s init start", SIMPLE_NAME);
+        setLoaded(loadLibrary());
         debug("%s libraryLoaded = %s, libraryLoadingError = %s", SIMPLE_NAME, libraryLoaded, libraryLoadingError);
-        debug("%s static init end", SIMPLE_NAME);
+        debug("%s init end", SIMPLE_NAME);
+    }
+
+    private static void setLoaded(Throwable tmp) {
+        libraryLoadingError = tmp; // will be null if loaded OK
+        libraryLoaded = libraryLoadingError == null;
     }
 
     /**
-     * Returns the given InputStream if it is already a {@link BufferedInputStream},
-     * otherwise creates a BufferedInputStream from the given InputStream.
+     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a BufferedInputStream from the given InputStream.
      * <p>
      * Copied from Apache Commons IO 2.5.
      * </p>
      *
      * @param inputStream the InputStream to wrap or return (not null)
-     * @return the given InputStream or a new {@link BufferedInputStream} for the
-     *         given InputStream
+     * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream
      * @throws NullPointerException if the input parameter is null
      */
     @SuppressWarnings("resource")
@@ -78,8 +87,7 @@ private static BufferedInputStream buffer(final InputStream inputStream) {
         // reject null early on rather than waiting for IO operation to fail
         // not checked by BufferedInputStream
         Objects.requireNonNull(inputStream, "inputStream");
-        return inputStream instanceof BufferedInputStream ? (BufferedInputStream) inputStream
-                : new BufferedInputStream(inputStream);
+        return inputStream instanceof BufferedInputStream ? (BufferedInputStream) inputStream : new BufferedInputStream(inputStream);
     }
 
     /**
@@ -118,7 +126,7 @@ private static boolean contentsEquals(final InputStream input1, final InputStrea
      * Logs debug messages.
      *
      * @param format See {@link String#format(String, Object...)}.
-     * @param args   See {@link String#format(String, Object...)}.
+     * @param args See {@link String#format(String, Object...)}.
      */
     private static void debug(final String format, final Object... args) {
         // TODO Find a better way to do this later.
@@ -134,13 +142,11 @@ private static void debug(final String format, final Object... args) {
      * Extracts the specified library file to the target folder.
      *
      * @param libFolderForCurrentOS the library in commons-crypto.lib.path.
-     * @param libraryFileName       the library name.
-     * @param targetFolder          Target folder for the native lib. Use the value
-     *                              of commons-crypto.tempdir or java.io.tmpdir.
+     * @param libraryFileName the library name.
+     * @param targetFolder Target folder for the native lib. Use the value of commons-crypto.tempdir or java.io.tmpdir.
      * @return the library file.
      */
-    private static File extractLibraryFile(final String libFolderForCurrentOS, final String libraryFileName,
-            final String targetFolder) {
+    private static File extractLibraryFile(final String libFolderForCurrentOS, final String libraryFileName, final String targetFolder) {
         final String nativeLibraryFilePath = libFolderForCurrentOS + File.separator + libraryFileName;
 
         // Attach UUID to the native library file to ensure multiple class loaders
@@ -148,10 +154,10 @@ private static File extractLibraryFile(final String libFolderForCurrentOS, final
         final UUID uuid = UUID.randomUUID();
         final String extractedLibFileName = String.format("commons-crypto-%s-%s", uuid, libraryFileName);
         final File extractedLibFile = new File(targetFolder, extractedLibFileName);
-        debug("Extracting '%s' to '%s'...", nativeLibraryFilePath, extractedLibFile);
+        debug("%s extracting '%s' to '%s'...", SIMPLE_NAME, nativeLibraryFilePath, extractedLibFile);
         try (InputStream inputStream = NativeCodeLoader.class.getResourceAsStream(nativeLibraryFilePath)) {
             if (inputStream == null) {
-                debug("Resource not found: %s", nativeLibraryFilePath);
+                debug("%s resource not found: %s", SIMPLE_NAME, nativeLibraryFilePath);
                 return null;
             }
             // Extract a native library file into the target directory
@@ -160,23 +166,21 @@ private static File extractLibraryFile(final String libFolderForCurrentOS, final
                 path = extractedLibFile.toPath();
                 final long byteCount = Files.copy(inputStream, path, StandardCopyOption.REPLACE_EXISTING);
                 if (isDebug()) {
-                    debug("Extracted '%s' to '%s': %,d bytes [%s]", nativeLibraryFilePath, extractedLibFile, byteCount,
+                    debug("%s extracted '%s' to '%s': %,d bytes [%s]", SIMPLE_NAME, nativeLibraryFilePath, extractedLibFile, byteCount,
                             Files.isExecutable(path) ? "X+" : "X-");
                     final PosixFileAttributes attributes = Files.readAttributes(path, PosixFileAttributes.class);
                     if (attributes != null) {
-                        debug("Attributes '%s': %s %s %s", extractedLibFile, attributes.permissions(),
-                                attributes.owner(), attributes.group());
+                        debug("%s attributes '%s': %s %s %s", SIMPLE_NAME, extractedLibFile, attributes.permissions(), attributes.owner(), attributes.group());
                     }
                 }
             } finally {
                 // Delete the extracted lib file on JVM exit.
-                debug("Delete on exit: %s", extractedLibFile);
+                debug("%s delete on exit: '%s'", SIMPLE_NAME, extractedLibFile);
                 extractedLibFile.deleteOnExit();
             }
 
             // Set executable (x) flag to enable Java to load the native library
-            if (!extractedLibFile.setReadable(true) || !extractedLibFile.setExecutable(true)
-                    || !extractedLibFile.setWritable(true, true)) {
+            if (!extractedLibFile.setReadable(true) || !extractedLibFile.setExecutable(true) || !extractedLibFile.setWritable(true, true)) {
                 throw new IllegalStateException("Invalid path for library path " + extractedLibFile);
             }
 
@@ -184,16 +188,17 @@ private static File extractLibraryFile(final String libFolderForCurrentOS, final
             // folder
             try (InputStream nativeInputStream = NativeCodeLoader.class.getResourceAsStream(nativeLibraryFilePath)) {
                 try (InputStream extractedLibIn = Files.newInputStream(path)) {
-                    debug("Validating '%s'...", extractedLibFile);
+                    debug("%s validating '%s'", SIMPLE_NAME, extractedLibFile);
                     if (!contentsEquals(nativeInputStream, extractedLibIn)) {
-                        throw new IllegalStateException(String.format("Failed to write a native library file %s to %s",
-                                nativeLibraryFilePath, extractedLibFile));
+                        throw new IllegalStateException(
+                                String.format("%s Failed to write a native library file %s to %s", SIMPLE_NAME, nativeLibraryFilePath, extractedLibFile));
                     }
+                    debug("%s validated '%s'", SIMPLE_NAME, extractedLibFile);
                 }
             }
             return extractedLibFile;
         } catch (final IOException e) {
-            debug("Ignoring %s", e);
+            debug("%s Ignoring %s", SIMPLE_NAME, e);
             return null;
         }
     }
@@ -203,49 +208,102 @@ private static File extractLibraryFile(final String libFolderForCurrentOS, final
      *
      * @return the jar file.
      */
-    private static File findNativeLibrary() {
+    private static File loadNativeLibrary() {
+        debug("%s findNativeLibrary", SIMPLE_NAME);
+        File file = findNativeLibrary(NATIVE_LIBNAME_OSSL3, NATIVE_LIBNAME_ALT_MAC_OSSL3, false);
+        if (file != null) {
+            try {
+                return systemLoad(file);
+            } catch (UnsatisfiedLinkError e) {
+                file = null;
+                debug("%s findNativeLibrary %s", SIMPLE_NAME, e);
+            }
+        }
+        file = findNativeLibrary(NATIVE_LIBNAME_OSSL1, NATIVE_LIBNAME_ALT_MAC_OSSL1, false);
+        if (file != null) {
+            return systemLoad(file);
+        }
+        return null;
+    }
+
+    /**
+     * Finds the native library.
+     *
+     * @return the jar file.
+     */
+    static File loadNativeLibrary1() {
+        File file = systemLoad(findNativeLibrary(NATIVE_LIBNAME_OSSL1, NATIVE_LIBNAME_ALT_MAC_OSSL1, true));
+        setLoaded(null);
+        init = true;
+        return file;
+    }
+
+    /**
+     * Finds the native library.
+     *
+     * @return the jar file.
+     */
+    static File loadNativeLibrary3() {
+        File file = systemLoad(findNativeLibrary(NATIVE_LIBNAME_OSSL3, NATIVE_LIBNAME_ALT_MAC_OSSL3, true));
+        setLoaded(null);
+        init = true;
+        return file;
+    }
+
+    /**
+     * Finds the native library.
+     *
+     * @return the jar file.
+     */
+    private static File findNativeLibrary(final String nativeLibName, final String nativeLibAltMacName, boolean failFast) {
+        debug("%s findNativeLibrary nativeLibName = '%s', nativeLibAltName = '%s'", SIMPLE_NAME, nativeLibName, nativeLibAltMacName);
         // Get the properties once
-        final Properties props = Utils.getDefaultProperties();
+        final Properties properties = Utils.getDefaultProperties();
 
         // Try to load the library in commons-crypto.lib.path */
-        String nativeLibraryPath = props.getProperty(Crypto.LIB_PATH_KEY);
-        String nativeLibraryName = props.getProperty(Crypto.LIB_NAME_KEY, System.mapLibraryName(NATIVE_LIBNAME));
+        String nativeLibraryPath = properties.getProperty(Crypto.LIB_PATH_KEY);
+        String nativeLibraryName = properties.getProperty(Crypto.LIB_NAME_KEY, System.mapLibraryName(nativeLibName));
 
-        debug("%s nativeLibraryPath %s = %s", SIMPLE_NAME, Crypto.LIB_PATH_KEY, nativeLibraryPath);
-        debug("%s nativeLibraryName %s = %s", SIMPLE_NAME, Crypto.LIB_NAME_KEY, nativeLibraryName);
+        debug("%s nativeLibraryPath %s = '%s'", SIMPLE_NAME, Crypto.LIB_PATH_KEY, nativeLibraryPath);
+        debug("%s nativeLibraryName %s = '%s'", SIMPLE_NAME, Crypto.LIB_NAME_KEY, nativeLibraryName);
 
         if (nativeLibraryPath != null) {
             final File nativeLib = new File(nativeLibraryPath, nativeLibraryName);
             final boolean exists = nativeLib.exists();
-            debug("%s nativeLib %s exists = %s", SIMPLE_NAME, nativeLib, exists);
+            debug("%s nativeLib %s file exists = %s", SIMPLE_NAME, nativeLib, exists);
             if (exists) {
                 return nativeLib;
             }
         }
 
         // Load an OS-dependent native library inside a jar file
-        nativeLibraryPath = "/org/apache/commons/crypto/native/" + OsInfo.getNativeLibFolderPathForCurrentOS();
-        debug("%s nativeLibraryPath = %s", SIMPLE_NAME, nativeLibraryPath);
+        nativeLibraryPath = "/org/apache/commons/crypto/native/" + OsInfo.getNativeLibFolder();
+        debug("%s nativeLibraryPath = '%s'", SIMPLE_NAME, nativeLibraryPath);
         final String resource = nativeLibraryPath + File.separator + nativeLibraryName;
         boolean hasNativeLib = hasResource(resource);
-        debug("%s resource %s exists = %s", SIMPLE_NAME, resource, hasNativeLib);
+        debug("%s resource '%s' exists = %s", SIMPLE_NAME, resource, hasNativeLib);
         if (!hasNativeLib) {
-            final String altName = NATIVE_LIBNAME_ALT;
-            if (OsInfo.getOSName().equals("Mac") && hasResource(nativeLibraryPath + File.separator + altName)) {
-                // Fix for openjdk7 for Mac
+            final String altName = nativeLibAltMacName;
+            String macResource = nativeLibraryPath + File.separator + altName;
+            if (OsInfo.getOsName().equals("Mac") && hasResource(macResource)) {
+                // Fix for openjdk7 for Mac, still applies on Java 8?
                 nativeLibraryName = altName;
                 hasNativeLib = true;
             }
+            debug("%s mac resource '%s' exists = %s", SIMPLE_NAME, macResource, hasNativeLib);
         }
 
         if (!hasNativeLib) {
-            final String errorMessage = String.format("No native library is found for os.name=%s and os.arch=%s", OsInfo.getOSName(), OsInfo.getArchName());
-            throw new IllegalStateException(errorMessage);
+            if (failFast) {
+                throw new IllegalStateException(
+                        String.format("No native library is found for os.name=%s and os.arch=%s", OsInfo.getOsName(), OsInfo.getArchName()));
+            }
+            return null;
         }
 
         // Temporary folder for the native lib. Use the value of
         // Crypto.LIB_TEMPDIR_KEY or java.io.tmpdir
-        final String tempFolder = new File(props.getProperty(Crypto.LIB_TEMPDIR_KEY, System.getProperty("java.io.tmpdir"))).getAbsolutePath();
+        final String tempFolder = new File(properties.getProperty(Crypto.LIB_TEMPDIR_KEY, System.getProperty("java.io.tmpdir"))).getAbsolutePath();
 
         // Extract and load a native library inside the jar file
         return extractLibraryFile(nativeLibraryPath, nativeLibraryName, tempFolder);
@@ -257,6 +315,7 @@ private static File findNativeLibrary() {
      * @return null, unless loading failed
      */
     static Throwable getLoadingError() {
+        init();
         return libraryLoadingError;
     }
 
@@ -280,6 +339,7 @@ private static boolean isDebug() {
      * @return {@code true} if native is loaded, else {@code false}.
      */
     static boolean isNativeCodeLoaded() {
+        init();
         return libraryLoaded;
     }
 
@@ -289,25 +349,36 @@ static boolean isNativeCodeLoaded() {
      * @return null if successful, otherwise the Throwable that was caught
      */
     static Throwable loadLibrary() {
+        init();
         try {
-            final File nativeLibFile = findNativeLibrary();
+            debug("%s loadLibrary", SIMPLE_NAME);
+            final File nativeLibFile = loadNativeLibrary();
             if (nativeLibFile != null) {
                 // Load extracted or specified native library.
-                final String absolutePath = nativeLibFile.getAbsolutePath();
-                debug("%s System.load('%s')", SIMPLE_NAME, absolutePath);
-                System.load(absolutePath);
+                systemLoad(nativeLibFile);
             } else {
-                // Load preinstalled library (in the path -Djava.library.path)
-                final String libname = NATIVE_LIBNAME;
-                debug("%s System.loadLibrary('%s')", SIMPLE_NAME, libname);
-                System.loadLibrary(libname);
+                // Load preinstalled library in the path for system property
+                // "java.library.path".
+                final String libName = NATIVE_LIBNAME_OSSL1;
+                debug("%s System.loadLibrary('%s')", SIMPLE_NAME, libName);
+                System.loadLibrary(libName);
             }
             return null; // OK
         } catch (final Exception | UnsatisfiedLinkError t) {
+            t.printStackTrace();
             return t;
         }
     }
 
+    private static File systemLoad(final File nativeLibFile) {
+        final String absolutePath = Objects.requireNonNull(nativeLibFile, "nativeLibFile").getAbsolutePath();
+        debug("%s System.load('%s')", SIMPLE_NAME, absolutePath);
+        System.load(absolutePath); // UnsatisfiedLinkError
+        debug("%s System loaded '%s'", SIMPLE_NAME, absolutePath);
+        // debug("%s OpenSSL %s", SIMPLE_NAME, OpenSslInfo.getOpenSslNativeVersion());
+        return nativeLibFile;
+    }
+
     /**
      * The private constructor of {@link NativeCodeLoader}.
      */
diff --git a/src/main/java/org/apache/commons/crypto/OpenSslInfo.java b/src/main/java/org/apache/commons/crypto/OpenSslInfo.java
new file mode 100644
index 0000000..7a1c6f1
--- /dev/null
+++ b/src/main/java/org/apache/commons/crypto/OpenSslInfo.java
@@ -0,0 +1,46 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package org.apache.commons.crypto;
+
+/**
+ * Provides OpenSSL information.
+ *
+ * @since 1.2.0
+ */
+public final class OpenSslInfo {
+
+    private static final long VERSION_3_0_X = 0x30000000;
+
+    /**
+     * Gets the OpenSSL version.
+     *
+     * @return the OpenSSL version.
+     */
+    public static long getOpenSslNativeVersion() {
+        return OpenSslInfoNative.OpenSSL();
+    }
+
+	/**
+     * Tests if the OpenSSL version is 3 or above.
+     *
+     * @return true if the OpenSSL version is 3 or above.
+     */
+	public static boolean isOpenSslNativeVersion3() {
+		return getOpenSslNativeVersion() >= OpenSslInfo.VERSION_3_0_X;
+	}
+}
diff --git a/src/main/java/org/apache/commons/crypto/OsInfo.java b/src/main/java/org/apache/commons/crypto/OsInfo.java
index a692d82..d719274 100644
--- a/src/main/java/org/apache/commons/crypto/OsInfo.java
+++ b/src/main/java/org/apache/commons/crypto/OsInfo.java
@@ -131,7 +131,7 @@ static String getArchName() {
                 return string;
             }
         }
-        return translateArchNameToFolderName(osArch);
+        return archNameToFolderName(osArch);
     }
 
     /**
@@ -139,8 +139,8 @@ static String getArchName() {
      *
      * @return the current OS's native lib folder.
      */
-    static String getNativeLibFolderPathForCurrentOS() {
-        return getOSName() + File.separator + getArchName();
+    static String getNativeLibFolder() {
+        return getOsName() + File.separator + getArchName();
     }
 
     /**
@@ -148,8 +148,8 @@ static String getNativeLibFolderPathForCurrentOS() {
      *
      * @return the OS name.
      */
-    static String getOSName() {
-        return translateOSNameToFolderName(getOsNameProperty());
+    static String getOsName() {
+        return osNameToFolderName(getOsNameProperty());
     }
 
     static String getOsNameProperty() {
@@ -164,7 +164,7 @@ static String getOsNameProperty() {
     public static void main(final String[] args) {
         if (args.length >= 1) {
             if ("--os".equals(args[0])) {
-                System.out.println(getOSName());
+                System.out.println(getOsName());
                 return;
             }
             if ("--arch".equals(args[0])) {
@@ -173,7 +173,7 @@ public static void main(final String[] args) {
             }
         }
 
-        System.out.println(getNativeLibFolderPathForCurrentOS());
+        System.out.println(getNativeLibFolder());
     }
 
     /**
@@ -182,7 +182,7 @@ public static void main(final String[] args) {
      * @param archName the architecture name.
      * @return the folder name.
      */
-    private static String translateArchNameToFolderName(final String archName) {
+    private static String archNameToFolderName(final String archName) {
         return archName.replaceAll("\\W", "");
     }
 
@@ -192,7 +192,7 @@ private static String translateArchNameToFolderName(final String archName) {
      * @param osName the OS name.
      * @return the folder name.
      */
-    private static String translateOSNameToFolderName(final String osName) {
+    private static String osNameToFolderName(final String osName) {
         if (osName.contains("Windows")) {
             return "Windows";
         }
diff --git a/src/main/java/org/apache/commons/crypto/cipher/AbstractOpenSslFeedbackCipher.java b/src/main/java/org/apache/commons/crypto/cipher/AbstractOpenSslFeedbackCipher.java
index 969d06b..1f3733a 100644
--- a/src/main/java/org/apache/commons/crypto/cipher/AbstractOpenSslFeedbackCipher.java
+++ b/src/main/java/org/apache/commons/crypto/cipher/AbstractOpenSslFeedbackCipher.java
@@ -50,7 +50,7 @@ public void checkState() {
 
     public void clean() {
         if (context != 0) {
-            OpenSslNative.clean(context);
+            OpenSslNativeJni._clean(context);
             context = 0;
         }
     }
diff --git a/src/main/java/org/apache/commons/crypto/cipher/OpenSsl.java b/src/main/java/org/apache/commons/crypto/cipher/OpenSsl.java
index c3ba228..79e11f5 100644
--- a/src/main/java/org/apache/commons/crypto/cipher/OpenSsl.java
+++ b/src/main/java/org/apache/commons/crypto/cipher/OpenSsl.java
@@ -68,7 +68,7 @@ static int get(final String algorithm, final String mode) throws NoSuchAlgorithm
         Throwable loadingFailure = null;
         try {
             if (Crypto.isNativeCodeLoaded()) {
-                OpenSslNative.initIDs();
+                OpenSslNativeJni._initIDs();
             } else {
                 loadingFailure = Crypto.getLoadingError();
             }
@@ -101,7 +101,7 @@ public static OpenSsl getInstance(final String transformation)
         final Transformation transform = Transformation.parse(transformation);
         final int algorithmMode = AlgorithmMode.get(transform.getAlgorithm(), transform.getMode());
         final int padding = transform.getPadding().ordinal();
-        final long context = OpenSslNative.initContext(algorithmMode, padding);
+        final long context = OpenSslNativeJni._initContext(algorithmMode, padding);
         return new OpenSsl(context, algorithmMode, padding);
     }
 
diff --git a/src/main/java/org/apache/commons/crypto/cipher/OpenSsl3Native.java b/src/main/java/org/apache/commons/crypto/cipher/OpenSsl3Native.java
new file mode 100644
index 0000000..2410630
--- /dev/null
+++ b/src/main/java/org/apache/commons/crypto/cipher/OpenSsl3Native.java
@@ -0,0 +1,197 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+* <p>
+* http://www.apache.org/licenses/LICENSE-2.0
+* <p>
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package org.apache.commons.crypto.cipher;
+
+import java.nio.ByteBuffer;
+
+/**
+ * JNI interface of {@link OpenSsl} implementation. The native method in this class is defined in OpenSslNative.h (generated by javah).
+ */
+final class OpenSsl3Native implements OpenSslNativeImpl {
+
+    /**
+     * Cleans the context at native.
+     *
+     * @param context The cipher context address
+     */
+    native void clean(long context);
+
+    /**
+     * Allows various cipher specific parameters to be determined and set.
+     *
+     * it will call OpenSSL's API int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr) In OpenSSL, data type of ptr can be char* or long*.
+     * Here, we map java's byte[] to native void*ptr. Note that the byte order is ByteOrder.nativeOrder.
+     *
+     * @param context The cipher context address
+     * @param type    CtrlValues
+     * @param arg     argument like a tag length
+     * @param data    byte buffer or null
+     * @return return 0 if there is any error, else return 1.
+     */
+    native int ctrl(long context, int type, int arg, byte[] data);
+
+    /**
+     * Finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
+     *
+     * @param context         The cipher context address
+     * @param output          The byte buffer for the result
+     * @param offset          The offset in output where the result is stored
+     * @param maxOutputLength The maximum length for output
+     * @return The number of bytes stored in output
+     */
+    native int doFinal(long context, ByteBuffer output, int offset, int maxOutputLength);
+
+    /**
+     * Finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
+     *
+     * @param context         The cipher context address
+     * @param output          The byte array for the result
+     * @param offset          The offset in output where the result is stored
+     * @param maxOutputLength The maximum length for output
+     * @return The number of bytes stored in output
+     */
+    native int doFinalByteArray(long context, byte[] output, int offset, int maxOutputLength);
+
+    /**
+     * Declares a native method to initialize the cipher context.
+     *
+     * @param context The cipher context address
+     * @param mode    ENCRYPT_MODE or DECRYPT_MODE
+     * @param alg     Algorithm Mode of OpenSsl
+     * @param padding the padding mode of OpenSsl cipher
+     * @param key     crypto key
+     * @param iv      crypto iv
+     * @return the context address of cipher
+     */
+    native long init(long context, int mode, int alg, int padding, byte[] key, byte[] iv);
+
+    /**
+     * Declares a native method to initialize the cipher context.
+     *
+     * @param algorithm The algorithm name of cipher
+     * @param padding   The padding name of cipher
+     * @return the context address of cipher
+     */
+    native long initContext(int algorithm, int padding);
+
+    /**
+     * Declares a native method to initialize JNI field and method IDs.
+     */
+    native void initIDs();
+
+    /**
+     * Continues a multiple-part encryption/decryption operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
+     *
+     * @param context         The cipher context address
+     * @param input           The input byte buffer
+     * @param inputOffset     The offset in input where the input starts
+     * @param inputLength     The input length
+     * @param output          The byte buffer for the result
+     * @param outputOffset    The offset in output where the result is stored
+     * @param maxOutputLength The maximum length for output
+     * @return The number of bytes stored in output
+     */
+    native int update(long context, ByteBuffer input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset, int maxOutputLength);
+
+    /**
+     * Continues a multiple-part encryption/decryption operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
+     *
+     * @param context         The cipher context address
+     * @param input           The input byte array
+     * @param inputOffset     The offset in input where the input starts
+     * @param inputLength     The input length
+     * @param output          The byte array for the result
+     * @param outputOffset    The offset in output where the result is stored
+     * @param maxOutputLength The maximum length for output
+     * @return The number of bytes stored in output
+     */
+    native int updateByteArray(long context, byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength);
+
+    /**
+     * Continues a multiple-part encryption/decryption operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
+     *
+     * @param context         The cipher context address
+     * @param input           The input byte array
+     * @param inputOffset     The offset in input where the input starts
+     * @param inputLength     The input length
+     * @param output          The byte buffer for the result
+     * @param outputOffset    The offset in output where the result is stored
+     * @param maxOutputLength The maximum length for output
+     * @return The number of bytes stored in output
+     */
+    native int updateByteArrayByteBuffer(long context, byte[] input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset,
+            int maxOutputLength);
+
+    /**
+     * Hides constructor from external access.
+     */
+    OpenSsl3Native() {
+    }
+
+    @Override
+    public void _clean(long context) {
+        clean(context);
+    }
+
+    @Override
+    public int _ctrl(long context, int type, int arg, byte[] data) {
+        return ctrl(context, type, arg, data);
+    }
+
+    @Override
+    public int _doFinal(long context, ByteBuffer output, int offset, int maxOutputLength) {
+        return doFinal(context, output, offset, maxOutputLength);
+    }
+
+    @Override
+    public int _doFinalByteArray(long context, byte[] output, int offset, int maxOutputLength) {
+        return doFinalByteArray(context, output, offset, maxOutputLength);
+    }
+
+    @Override
+    public long _init(long context, int mode, int alg, int padding, byte[] key, byte[] iv) {
+        return init(context, mode, alg, padding, key, iv);
+    }
+
+    @Override
+    public long _initContext(int algorithm, int padding) {
+        return initContext(algorithm, padding);
+    }
+
+    @Override
+    public void _initIDs() {
+        initIDs();
+
+    }
+
+    @Override
+    public int _update(long context, ByteBuffer input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset, int maxOutputLength) {
+        return update(context, input, inputOffset, inputLength, output, outputOffset, maxOutputLength);
+    }
+
+    @Override
+    public int _updateByteArray(long context, byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength) {
+        return updateByteArray(context, input, inputOffset, inputLength, output, outputOffset, maxOutputLength);
+    }
+
+    @Override
+    public int _updateByteArrayByteBuffer(long context, byte[] input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset,
+            int maxOutputLength) {
+        return updateByteArrayByteBuffer(context, input, inputOffset, inputLength, output, outputOffset, maxOutputLength);
+    }
+}
diff --git a/src/main/java/org/apache/commons/crypto/cipher/OpenSslCommonMode.java b/src/main/java/org/apache/commons/crypto/cipher/OpenSslCommonMode.java
index 367da36..2bf1b93 100644
--- a/src/main/java/org/apache/commons/crypto/cipher/OpenSslCommonMode.java
+++ b/src/main/java/org/apache/commons/crypto/cipher/OpenSslCommonMode.java
@@ -38,15 +38,45 @@ final class OpenSslCommonMode extends AbstractOpenSslFeedbackCipher {
         super(context, algorithmMode, padding);
     }
 
+    @Override
+    public void init(final int mode, final byte[] key, final AlgorithmParameterSpec params) throws InvalidAlgorithmParameterException {
+        this.cipherMode = mode;
+        final byte[] iv;
+        if (!(params instanceof IvParameterSpec)) {
+            // other AlgorithmParameterSpec is not supported now.
+            throw new InvalidAlgorithmParameterException("Illegal parameters");
+        }
+        iv = ((IvParameterSpec) params).getIV();
+        context = OpenSslNativeJni._init(context, mode, algorithmMode, padding, key, iv);
+    }
+
+    @Override
+    public int update(final ByteBuffer input, final ByteBuffer output) throws ShortBufferException {
+        checkState();
+
+        final int len = OpenSslNativeJni._update(context, input, input.position(), input.remaining(), output, output.position(), output.remaining());
+        input.position(input.limit());
+        output.position(output.position() + len);
+
+        return len;
+    }
+
+    @Override
+    public int update(final byte[] input, final int inputOffset, final int inputLen, final byte[] output, final int outputOffset) throws ShortBufferException {
+        checkState();
+
+        return OpenSslNativeJni._updateByteArray(context, input, inputOffset, inputLen, output, outputOffset, output.length - outputOffset);
+    }
+
     @Override
     public int doFinal(final byte[] input, final int inputOffset, final int inputLen, final byte[] output, final int outputOffset)
             throws ShortBufferException, IllegalBlockSizeException, BadPaddingException {
         checkState();
         final int outputLength = output.length;
 
-        int len = OpenSslNative.updateByteArray(context, input, inputOffset, inputLen, output, outputOffset, outputLength - outputOffset);
+        int len = OpenSslNativeJni._updateByteArray(context, input, inputOffset, inputLen, output, outputOffset, outputLength - outputOffset);
 
-        len += OpenSslNative.doFinalByteArray(context, output, outputOffset + len, outputLength - outputOffset - len);
+        len += OpenSslNativeJni._doFinalByteArray(context, output, outputOffset + len, outputLength - outputOffset - len);
 
         return len;
     }
@@ -56,13 +86,13 @@ public int doFinal(final ByteBuffer input, final ByteBuffer output) throws Short
         checkState();
 
         int totalLen = 0;
-        int len = OpenSslNative.update(context, input, input.position(), input.remaining(), output, output.position(), output.remaining());
+        int len = OpenSslNativeJni._update(context, input, input.position(), input.remaining(), output, output.position(), output.remaining());
         totalLen += len;
 
         input.position(input.limit());
         output.position(output.position() + len);
 
-        len = OpenSslNative.doFinal(context, output, output.position(), output.remaining());
+        len = OpenSslNativeJni._doFinal(context, output, output.position(), output.remaining());
         totalLen += len;
 
         output.position(output.position() + len);
@@ -70,36 +100,6 @@ public int doFinal(final ByteBuffer input, final ByteBuffer output) throws Short
         return totalLen;
     }
 
-    @Override
-    public void init(final int mode, final byte[] key, final AlgorithmParameterSpec params) throws InvalidAlgorithmParameterException {
-        this.cipherMode = mode;
-        final byte[] iv;
-        if (!(params instanceof IvParameterSpec)) {
-            // other AlgorithmParameterSpec is not supported now.
-            throw new InvalidAlgorithmParameterException("Illegal parameters");
-        }
-        iv = ((IvParameterSpec) params).getIV();
-        context = OpenSslNative.init(context, mode, algorithmMode, padding, key, iv);
-    }
-
-    @Override
-    public int update(final byte[] input, final int inputOffset, final int inputLen, final byte[] output, final int outputOffset) throws ShortBufferException {
-        checkState();
-
-        return OpenSslNative.updateByteArray(context, input, inputOffset, inputLen, output, outputOffset, output.length - outputOffset);
-    }
-
-    @Override
-    public int update(final ByteBuffer input, final ByteBuffer output) throws ShortBufferException {
-        checkState();
-
-        final int len = OpenSslNative.update(context, input, input.position(), input.remaining(), output, output.position(), output.remaining());
-        input.position(input.limit());
-        output.position(output.position() + len);
-
-        return len;
-    }
-
     @Override
     public void updateAAD(final byte[] aad) {
         throw new UnsupportedOperationException("The underlying Cipher implementation does not support this method");
diff --git a/src/main/java/org/apache/commons/crypto/cipher/OpenSslGaloisCounterMode.java b/src/main/java/org/apache/commons/crypto/cipher/OpenSslGaloisCounterMode.java
index ba73fe6..f035bf7 100644
--- a/src/main/java/org/apache/commons/crypto/cipher/OpenSslGaloisCounterMode.java
+++ b/src/main/java/org/apache/commons/crypto/cipher/OpenSslGaloisCounterMode.java
@@ -52,9 +52,74 @@ public OpenSslGaloisCounterMode(final long context, final int algorithmMode, fin
     }
 
     @Override
-    public void clean() {
-        super.clean();
-        aadBuffer = null;
+    public void init(final int mode, final byte[] key, final AlgorithmParameterSpec params)
+            throws InvalidAlgorithmParameterException {
+
+        if (aadBuffer == null) {
+            aadBuffer = new ByteArrayOutputStream();
+        } else {
+            aadBuffer.reset();
+        }
+
+        this.cipherMode = mode;
+        final byte[] iv;
+        if (!(params instanceof GCMParameterSpec)) {
+            // other AlgorithmParameterSpec is not supported now.
+            throw new InvalidAlgorithmParameterException("Illegal parameters");
+        }
+        final GCMParameterSpec gcmParam = (GCMParameterSpec) params;
+        iv = gcmParam.getIV();
+        this.tagBitLen = gcmParam.getTLen();
+
+        if (this.cipherMode == OpenSsl.DECRYPT_MODE) {
+            inBuffer = new ByteArrayOutputStream();
+        }
+
+        context = OpenSslNativeJni._init(context, mode, algorithmMode, padding, key, iv);
+    }
+
+    @Override
+    public int update(final ByteBuffer input, final ByteBuffer output) throws ShortBufferException {
+        checkState();
+
+        processAAD();
+
+        final int len;
+        if (this.cipherMode == OpenSsl.DECRYPT_MODE) {
+            // store internally until doFinal(decrypt) is called because
+            // spec mentioned that only return recovered data after tag
+            // is successfully verified
+            final int inputLen = input.remaining();
+            final byte[] inputBuf = new byte[inputLen];
+            input.get(inputBuf, 0, inputLen);
+            inBuffer.write(inputBuf, 0, inputLen);
+            return 0;
+        }
+        len = OpenSslNativeJni._update(context, input, input.position(),
+                input.remaining(), output, output.position(),
+                output.remaining());
+        input.position(input.limit());
+        output.position(output.position() + len);
+
+        return len;
+    }
+
+    @Override
+    public int update(final byte[] input, final int inputOffset, final int inputLen, final byte[] output, final int outputOffset)
+            throws ShortBufferException {
+        checkState();
+
+        processAAD();
+
+        if (this.cipherMode == OpenSsl.DECRYPT_MODE) {
+            // store internally until doFinal(decrypt) is called because
+            // spec mentioned that only return recovered data after tag
+            // is successfully verified
+            inBuffer.write(input, inputOffset, inputLen);
+            return 0;
+        }
+        return OpenSslNativeJni._updateByteArray(context, input, inputOffset,
+                inputLen, output, outputOffset, output.length - outputOffset);
     }
 
     @Override
@@ -87,7 +152,7 @@ public int doFinal(final byte[] input, final int inputOffset, final int inputLen
             }
 
             final int inputDataLen = inputLenFinal - getTagLen();
-            len = OpenSslNative.updateByteArray(context, inputFinal, inputOffsetFinal,
+            len = OpenSslNativeJni._updateByteArray(context, inputFinal, inputOffsetFinal,
                     inputDataLen, output, outputOffset, outputLength - outputOffset);
 
             // set tag to EVP_Cipher for integrity verification in doFinal
@@ -96,11 +161,11 @@ public int doFinal(final byte[] input, final int inputOffset, final int inputLen
             tag.flip();
             evpCipherCtxCtrl(context, OpenSslEvpCtrlValues.AEAD_SET_TAG.getValue(), getTagLen(), tag);
         } else {
-            len = OpenSslNative.updateByteArray(context, input, inputOffset,
+            len = OpenSslNativeJni._updateByteArray(context, input, inputOffset,
                     inputLen, output, outputOffset, outputLength - outputOffset);
         }
 
-        len += OpenSslNative.doFinalByteArray(context, output, outputOffset + len,
+        len += OpenSslNativeJni._doFinalByteArray(context, output, outputOffset + len,
                 outputLength - outputOffset - len);
 
         // Keep the similar behavior as JCE, append the tag to end of output
@@ -140,7 +205,7 @@ public int doFinal(final ByteBuffer input, final ByteBuffer output)
                     throw new AEADBadTagException("Input too short - need tag");
                 }
 
-                len = OpenSslNative.updateByteArrayByteBuffer(context, inputFinal, 0,
+                len = OpenSslNativeJni._updateByteArrayByteBuffer(context, inputFinal, 0,
                         inputFinal.length - getTagLen(),
                         output, output.position(), output.remaining());
 
@@ -153,7 +218,7 @@ public int doFinal(final ByteBuffer input, final ByteBuffer output)
                     throw new AEADBadTagException("Input too short - need tag");
                 }
 
-                len = OpenSslNative.update(context, input, input.position(),
+                len = OpenSslNativeJni._update(context, input, input.position(),
                         input.remaining() - getTagLen(), output, output.position(),
                         output.remaining());
 
@@ -168,7 +233,7 @@ public int doFinal(final ByteBuffer input, final ByteBuffer output)
             evpCipherCtxCtrl(context, OpenSslEvpCtrlValues.AEAD_SET_TAG.getValue(),
                     getTagLen(), tag);
         } else {
-            len = OpenSslNative.update(context, input, input.position(),
+            len = OpenSslNativeJni._update(context, input, input.position(),
                     input.remaining(), output, output.position(),
                     output.remaining());
             input.position(input.limit());
@@ -177,7 +242,7 @@ public int doFinal(final ByteBuffer input, final ByteBuffer output)
         totalLen += len;
         output.position(output.position() + len);
 
-        len = OpenSslNative.doFinal(context, output, output.position(),
+        len = OpenSslNativeJni._doFinal(context, output, output.position(),
                 output.remaining());
         output.position(output.position() + len);
         totalLen += len;
@@ -194,6 +259,33 @@ public int doFinal(final ByteBuffer input, final ByteBuffer output)
         return totalLen;
     }
 
+    @Override
+    public void clean() {
+        super.clean();
+        aadBuffer = null;
+    }
+
+    @Override
+    public void updateAAD(final byte[] aad) {
+        // must be called after initialized.
+        if (aadBuffer == null) {
+            // update has already been called
+            throw new IllegalStateException("Update has been called; no more AAD data");
+        }
+        aadBuffer.write(aad, 0, aad.length);
+    }
+
+    private void processAAD() {
+        if (aadBuffer != null && aadBuffer.size() > 0) {
+            OpenSslNativeJni._updateByteArray(context, aadBuffer.toByteArray(), 0, aadBuffer.size(), null, 0, 0);
+            aadBuffer = null;
+        }
+    }
+
+    private int getTagLen() {
+        return tagBitLen < 0 ? DEFAULT_TAG_LEN : tagBitLen >> 3;
+    }
+
     /**
      * Wraps of OpenSslNative.ctrl(long context, int type, int arg, byte[] data)
      * Since native interface EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr) is generic,
@@ -211,104 +303,12 @@ private int evpCipherCtxCtrl(final long context, final int type, final int arg,
         try {
             if (data != null) {
                 data.order(ByteOrder.nativeOrder());
-                return OpenSslNative.ctrl(context, type, arg, data.array());
+                return OpenSslNativeJni._ctrl(context, type, arg, data.array());
             }
-            return OpenSslNative.ctrl(context, type, arg, null);
+            return OpenSslNativeJni._ctrl(context, type, arg, null);
         } catch (final Exception e) {
             System.out.println(e.getMessage());
             return 0;
         }
     }
-
-    private int getTagLen() {
-        return tagBitLen < 0 ? DEFAULT_TAG_LEN : tagBitLen >> 3;
-    }
-
-    @Override
-    public void init(final int mode, final byte[] key, final AlgorithmParameterSpec params)
-            throws InvalidAlgorithmParameterException {
-
-        if (aadBuffer == null) {
-            aadBuffer = new ByteArrayOutputStream();
-        } else {
-            aadBuffer.reset();
-        }
-
-        this.cipherMode = mode;
-        final byte[] iv;
-        if (!(params instanceof GCMParameterSpec)) {
-            // other AlgorithmParameterSpec is not supported now.
-            throw new InvalidAlgorithmParameterException("Illegal parameters");
-        }
-        final GCMParameterSpec gcmParam = (GCMParameterSpec) params;
-        iv = gcmParam.getIV();
-        this.tagBitLen = gcmParam.getTLen();
-
-        if (this.cipherMode == OpenSsl.DECRYPT_MODE) {
-            inBuffer = new ByteArrayOutputStream();
-        }
-
-        context = OpenSslNative.init(context, mode, algorithmMode, padding, key, iv);
-    }
-
-    private void processAAD() {
-        if (aadBuffer != null && aadBuffer.size() > 0) {
-            OpenSslNative.updateByteArray(context, aadBuffer.toByteArray(), 0, aadBuffer.size(), null, 0, 0);
-            aadBuffer = null;
-        }
-    }
-
-    @Override
-    public int update(final byte[] input, final int inputOffset, final int inputLen, final byte[] output, final int outputOffset)
-            throws ShortBufferException {
-        checkState();
-
-        processAAD();
-
-        if (this.cipherMode == OpenSsl.DECRYPT_MODE) {
-            // store internally until doFinal(decrypt) is called because
-            // spec mentioned that only return recovered data after tag
-            // is successfully verified
-            inBuffer.write(input, inputOffset, inputLen);
-            return 0;
-        }
-        return OpenSslNative.updateByteArray(context, input, inputOffset,
-                inputLen, output, outputOffset, output.length - outputOffset);
-    }
-
-    @Override
-    public int update(final ByteBuffer input, final ByteBuffer output) throws ShortBufferException {
-        checkState();
-
-        processAAD();
-
-        final int len;
-        if (this.cipherMode == OpenSsl.DECRYPT_MODE) {
-            // store internally until doFinal(decrypt) is called because
-            // spec mentioned that only return recovered data after tag
-            // is successfully verified
-            final int inputLen = input.remaining();
-            final byte[] inputBuf = new byte[inputLen];
-            input.get(inputBuf, 0, inputLen);
-            inBuffer.write(inputBuf, 0, inputLen);
-            return 0;
-        }
-        len = OpenSslNative.update(context, input, input.position(),
-                input.remaining(), output, output.position(),
-                output.remaining());
-        input.position(input.limit());
-        output.position(output.position() + len);
-
-        return len;
-    }
-
-    @Override
-    public void updateAAD(final byte[] aad) {
-        // must be called after initialized.
-        if (aadBuffer == null) {
-            // update has already been called
-            throw new IllegalStateException("Update has been called; no more AAD data");
-        }
-        aadBuffer.write(aad, 0, aad.length);
-    }
 }
diff --git a/src/main/java/org/apache/commons/crypto/cipher/OpenSslNative.java b/src/main/java/org/apache/commons/crypto/cipher/OpenSslNative.java
index dc62706..c4657bf 100644
--- a/src/main/java/org/apache/commons/crypto/cipher/OpenSslNative.java
+++ b/src/main/java/org/apache/commons/crypto/cipher/OpenSslNative.java
@@ -1,161 +1,198 @@
- /*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- * <p>
- * http://www.apache.org/licenses/LICENSE-2.0
- * <p>
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+* <p>
+* http://www.apache.org/licenses/LICENSE-2.0
+* <p>
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 package org.apache.commons.crypto.cipher;
 
 import java.nio.ByteBuffer;
 
 /**
- * JNI implementation for OpenSSL 1.x called from {@link OpenSsl}. The native methods in this
- * class are defined in OpenSslNative.h (generated by javah).
+ * JNI implementation for OpenSSL 1.x called from {@link OpenSsl}. The native methods in this class are defined in OpenSslNative.h (generated by javah).
  */
-final class OpenSslNative {
+final class OpenSslNative implements OpenSslNativeImpl {
 
     /**
      * Cleans the context at native.
      *
      * @param context The cipher context address
      */
-    public static native void clean(long context);
+    static native void clean(long context);
 
     /**
      * Allows various cipher specific parameters to be determined and set.
      *
-     * it will call OpenSSL's API
-     * int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
-     * In OpenSSL, data type of ptr can be char* or long*.  Here, we map java's
-     * byte[] to native void*ptr. Note that the byte order is ByteOrder.nativeOrder.
+     * it will call OpenSSL's API int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr) In OpenSSL, data type of ptr can be char* or long*.
+     * Here, we map java's byte[] to native void*ptr. Note that the byte order is ByteOrder.nativeOrder.
      *
      * @param context The cipher context address
-     * @param type CtrlValues
-     * @param arg argument like a tag length
-     * @param data byte buffer or null
+     * @param type    CtrlValues
+     * @param arg     argument like a tag length
+     * @param data    byte buffer or null
      * @return return 0 if there is any error, else return 1.
      */
-    public static native int ctrl(long context, int type, int arg, byte[] data);
+    static native int ctrl(long context, int type, int arg, byte[] data);
 
     /**
-     * Finishes a multiple-part operation. The data is encrypted or decrypted,
-     * depending on how this cipher was initialized.
+     * Finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
      *
-     * @param context The cipher context address
-     * @param output The byte buffer for the result
-     * @param offset The offset in output where the result is stored
+     * @param context         The cipher context address
+     * @param output          The byte buffer for the result
+     * @param offset          The offset in output where the result is stored
      * @param maxOutputLength The maximum length for output
      * @return The number of bytes stored in output
      */
-    public static native int doFinal(long context, ByteBuffer output,
-            int offset, int maxOutputLength);
+    static native int doFinal(long context, ByteBuffer output, int offset, int maxOutputLength);
 
     /**
-     * Finishes a multiple-part operation. The data is encrypted or decrypted,
-     * depending on how this cipher was initialized.
+     * Finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
      *
-     * @param context The cipher context address
-     * @param output The byte array for the result
-     * @param offset The offset in output where the result is stored
+     * @param context         The cipher context address
+     * @param output          The byte array for the result
+     * @param offset          The offset in output where the result is stored
      * @param maxOutputLength The maximum length for output
      * @return The number of bytes stored in output
      */
-    public static native int doFinalByteArray(long context, byte[] output,
-            int offset, int maxOutputLength);
+    static native int doFinalByteArray(long context, byte[] output, int offset, int maxOutputLength);
 
     /**
      * Declares a native method to initialize the cipher context.
      *
      * @param context The cipher context address
-     * @param mode ENCRYPT_MODE or DECRYPT_MODE
-     * @param alg Algorithm Mode of OpenSsl
+     * @param mode    ENCRYPT_MODE or DECRYPT_MODE
+     * @param alg     Algorithm Mode of OpenSsl
      * @param padding the padding mode of OpenSsl cipher
-     * @param key crypto key
-     * @param iv crypto iv
+     * @param key     crypto key
+     * @param iv      crypto iv
      * @return the context address of cipher
      */
-    public static native long init(long context, int mode, int alg,
-                                   int padding, byte[] key, byte[] iv);
+    static native long init(long context, int mode, int alg, int padding, byte[] key, byte[] iv);
 
     /**
      * Declares a native method to initialize the cipher context.
      *
      * @param algorithm The algorithm name of cipher
-     * @param padding The padding name of cipher
+     * @param padding   The padding name of cipher
      * @return the context address of cipher
      */
-    public static native long initContext(int algorithm, int padding);
+    static native long initContext(int algorithm, int padding);
 
     /**
      * Declares a native method to initialize JNI field and method IDs.
      */
-    public static native void initIDs();
+    static native void initIDs();
 
     /**
-     * Continues a multiple-part encryption/decryption operation. The data is
-     * encrypted or decrypted, depending on how this cipher was initialized.
+     * Continues a multiple-part encryption/decryption operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
      *
-     * @param context The cipher context address
-     * @param input The input byte buffer
-     * @param inputOffset The offset in input where the input starts
-     * @param inputLength The input length
-     * @param output The byte buffer for the result
-     * @param outputOffset The offset in output where the result is stored
+     * @param context         The cipher context address
+     * @param input           The input byte buffer
+     * @param inputOffset     The offset in input where the input starts
+     * @param inputLength     The input length
+     * @param output          The byte buffer for the result
+     * @param outputOffset    The offset in output where the result is stored
      * @param maxOutputLength The maximum length for output
      * @return The number of bytes stored in output
      */
-    public static native int update(long context, ByteBuffer input,
-            int inputOffset, int inputLength, ByteBuffer output,
-            int outputOffset, int maxOutputLength);
+    static native int update(long context, ByteBuffer input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset, int maxOutputLength);
 
     /**
-     * Continues a multiple-part encryption/decryption operation. The data is
-     * encrypted or decrypted, depending on how this cipher was initialized.
+     * Continues a multiple-part encryption/decryption operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
      *
-     * @param context The cipher context address
-     * @param input The input byte array
-     * @param inputOffset The offset in input where the input starts
-     * @param inputLength The input length
-     * @param output The byte array for the result
-     * @param outputOffset The offset in output where the result is stored
+     * @param context         The cipher context address
+     * @param input           The input byte array
+     * @param inputOffset     The offset in input where the input starts
+     * @param inputLength     The input length
+     * @param output          The byte array for the result
+     * @param outputOffset    The offset in output where the result is stored
      * @param maxOutputLength The maximum length for output
      * @return The number of bytes stored in output
      */
-    public static native int updateByteArray(long context, byte[] input,
-            int inputOffset, int inputLength, byte[] output, int outputOffset,
+    static native int updateByteArray(long context, byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset,
             int maxOutputLength);
 
     /**
-     * Continues a multiple-part encryption/decryption operation. The data is
-     * encrypted or decrypted, depending on how this cipher was initialized.
+     * Continues a multiple-part encryption/decryption operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
      *
-     * @param context The cipher context address
-     * @param input The input byte array
-     * @param inputOffset The offset in input where the input starts
-     * @param inputLength The input length
-     * @param output The byte buffer for the result
-     * @param outputOffset The offset in output where the result is stored
+     * @param context         The cipher context address
+     * @param input           The input byte array
+     * @param inputOffset     The offset in input where the input starts
+     * @param inputLength     The input length
+     * @param output          The byte buffer for the result
+     * @param outputOffset    The offset in output where the result is stored
      * @param maxOutputLength The maximum length for output
      * @return The number of bytes stored in output
      */
-    public static native int updateByteArrayByteBuffer(long context, byte[] input,
-                                                       int inputOffset, int inputLength,
-                                                       ByteBuffer output, int outputOffset, int maxOutputLength);
+    static native int updateByteArrayByteBuffer(long context, byte[] input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset,
+            int maxOutputLength);
 
     /**
      * Hides this constructor from external access.
      */
-    private OpenSslNative() {
+    OpenSslNative() {
+    }
+
+    @Override
+    public void _clean(long context) {
+        clean(context);
+    }
+
+    @Override
+    public int _ctrl(long context, int type, int arg, byte[] data) {
+        return ctrl(context, type, arg, data);
+    }
+
+    @Override
+    public int _doFinal(long context, ByteBuffer output, int offset, int maxOutputLength) {
+        return doFinal(context, output, offset, maxOutputLength);
+    }
+
+    @Override
+    public int _doFinalByteArray(long context, byte[] output, int offset, int maxOutputLength) {
+        return doFinalByteArray(context, output, offset, maxOutputLength);
+    }
+
+    @Override
+    public long _init(long context, int mode, int alg, int padding, byte[] key, byte[] iv) {
+        return init(context, mode, alg, padding, key, iv);
+    }
+
+    @Override
+    public long _initContext(int algorithm, int padding) {
+        return initContext(algorithm, padding);
+    }
+
+    @Override
+    public void _initIDs() {
+        initIDs();
+
+    }
+
+    @Override
+    public int _update(long context, ByteBuffer input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset, int maxOutputLength) {
+        return update(context, input, inputOffset, inputLength, output, outputOffset, maxOutputLength);
+    }
+
+    @Override
+    public int _updateByteArray(long context, byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength) {
+        return updateByteArray(context, input, inputOffset, inputLength, output, outputOffset, maxOutputLength);
+    }
+
+    @Override
+    public int _updateByteArrayByteBuffer(long context, byte[] input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset,
+            int maxOutputLength) {
+        return updateByteArrayByteBuffer(context, input, inputOffset, inputLength, output, outputOffset, maxOutputLength);
     }
 }
diff --git a/src/main/java/org/apache/commons/crypto/cipher/OpenSslNativeImpl.java b/src/main/java/org/apache/commons/crypto/cipher/OpenSslNativeImpl.java
new file mode 100644
index 0000000..ed6b7d9
--- /dev/null
+++ b/src/main/java/org/apache/commons/crypto/cipher/OpenSslNativeImpl.java
@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.crypto.cipher;
+
+import java.nio.ByteBuffer;
+
+/**
+ * JNI interface for native implementations.
+ */
+interface OpenSslNativeImpl {
+
+    /**
+     * Cleans the context at native.
+     *
+     * @param context The cipher context address
+     */
+    void _clean(long context);
+
+    /**
+     * Allows various cipher specific parameters to be determined and set.
+     *
+     * it will call OpenSSL's API int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr) In OpenSSL, data type of ptr can be char* or long*.
+     * Here, we map java's byte[] to native void*ptr. Note that the byte order is ByteOrder.nativeOrder.
+     *
+     * @param context The cipher context address
+     * @param type    CtrlValues
+     * @param arg     argument like a tag length
+     * @param data    byte buffer or null
+     * @return return 0 if there is any error, else return 1.
+     */
+    int _ctrl(long context, int type, int arg, byte[] data);
+
+    /**
+     * Finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
+     *
+     * @param context         The cipher context address
+     * @param output          The byte buffer for the result
+     * @param offset          The offset in output where the result is stored
+     * @param maxOutputLength The maximum length for output
+     * @return The number of bytes stored in output
+     */
+    int _doFinal(long context, ByteBuffer output, int offset, int maxOutputLength);
+
+    /**
+     * Finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
+     *
+     * @param context         The cipher context address
+     * @param output          The byte array for the result
+     * @param offset          The offset in output where the result is stored
+     * @param maxOutputLength The maximum length for output
+     * @return The number of bytes stored in output
+     */
+    int _doFinalByteArray(long context, byte[] output, int offset, int maxOutputLength);
+
+    /**
+     * Declares a native method to initialize the cipher context.
+     *
+     * @param context The cipher context address
+     * @param mode    ENCRYPT_MODE or DECRYPT_MODE
+     * @param alg     Algorithm Mode of OpenSsl
+     * @param padding the padding mode of OpenSsl cipher
+     * @param key     crypto key
+     * @param iv      crypto iv
+     * @return the context address of cipher
+     */
+    long _init(long context, int mode, int alg, int padding, byte[] key, byte[] iv);
+
+    /**
+     * Declares a native method to initialize the cipher context.
+     *
+     * @param algorithm The algorithm name of cipher
+     * @param padding   The padding name of cipher
+     * @return the context address of cipher
+     */
+    long _initContext(int algorithm, int padding);
+
+    /**
+     * Declares a native method to initialize JNI field and method IDs.
+     */
+    void _initIDs();
+
+    /**
+     * Continues a multiple-part encryption/decryption operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
+     *
+     * @param context         The cipher context address
+     * @param input           The input byte buffer
+     * @param inputOffset     The offset in input where the input starts
+     * @param inputLength     The input length
+     * @param output          The byte buffer for the result
+     * @param outputOffset    The offset in output where the result is stored
+     * @param maxOutputLength The maximum length for output
+     * @return The number of bytes stored in output
+     */
+    int _update(long context, ByteBuffer input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset, int maxOutputLength);
+
+    /**
+     * Continues a multiple-part encryption/decryption operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
+     *
+     * @param context         The cipher context address
+     * @param input           The input byte array
+     * @param inputOffset     The offset in input where the input starts
+     * @param inputLength     The input length
+     * @param output          The byte array for the result
+     * @param outputOffset    The offset in output where the result is stored
+     * @param maxOutputLength The maximum length for output
+     * @return The number of bytes stored in output
+     */
+    int _updateByteArray(long context, byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength);
+
+    /**
+     * Continues a multiple-part encryption/decryption operation. The data is encrypted or decrypted, depending on how this cipher was initialized.
+     *
+     * @param context         The cipher context address
+     * @param input           The input byte array
+     * @param inputOffset     The offset in input where the input starts
+     * @param inputLength     The input length
+     * @param output          The byte buffer for the result
+     * @param outputOffset    The offset in output where the result is stored
+     * @param maxOutputLength The maximum length for output
+     * @return The number of bytes stored in output
+     */
+    int _updateByteArrayByteBuffer(long context, byte[] input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset, int maxOutputLength);
+
+}
diff --git a/src/main/java/org/apache/commons/crypto/cipher/OpenSslNativeJni.java b/src/main/java/org/apache/commons/crypto/cipher/OpenSslNativeJni.java
new file mode 100644
index 0000000..dc02158
--- /dev/null
+++ b/src/main/java/org/apache/commons/crypto/cipher/OpenSslNativeJni.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.crypto.cipher;
+
+import java.nio.ByteBuffer;
+
+import org.apache.commons.crypto.OpenSslInfo;
+
+/**
+ * Delegates calls to a native library for a specific version of OpenSSL.
+ */
+public class OpenSslNativeJni {
+
+    private static final OpenSslNativeImpl nativeImpl;
+    static {
+        nativeImpl = OpenSslInfo.isOpenSslNativeVersion3() ? new OpenSsl3Native() : new OpenSslNative();
+    }
+
+	static void _clean(long context) {
+        nativeImpl._clean(context);
+    }
+
+    static int _ctrl(long context, int type, int arg, byte[] data) {
+        return nativeImpl._ctrl(context, type, arg, data);
+    }
+
+    static int _doFinal(long context, ByteBuffer output, int offset, int maxOutputLength) {
+        return nativeImpl._doFinal(context, output, offset, maxOutputLength);
+    }
+
+    static int _doFinalByteArray(long context, byte[] output, int offset, int maxOutputLength) {
+        return nativeImpl._doFinalByteArray(context, output, offset, maxOutputLength);
+    }
+
+    static long _init(long context, int mode, int alg, int padding, byte[] key, byte[] iv) {
+        return nativeImpl._init(context, mode, alg, padding, key, iv);
+    }
+
+    static long _initContext(int algorithm, int padding) {
+        return nativeImpl._initContext(algorithm, padding);
+    }
+
+    static void _initIDs() {
+        nativeImpl._initIDs();
+    }
+
+    static int _update(long context, ByteBuffer input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset, int maxOutputLength) {
+        return nativeImpl._update(context, input, inputOffset, inputLength, output, outputOffset, maxOutputLength);
+    }
+
+    static int _updateByteArray(long context, byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength) {
+        return nativeImpl._updateByteArray(context, input, inputOffset, inputLength, output, outputOffset, maxOutputLength);
+    }
+
+    static int _updateByteArrayByteBuffer(long context, byte[] input, int inputOffset, int inputLength, ByteBuffer output, int outputOffset,
+            int maxOutputLength) {
+        return nativeImpl._updateByteArrayByteBuffer(context, input, inputOffset, inputLength, output, outputOffset, maxOutputLength);
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/crypto/jna/OpenSsl30XNativeJna.java b/src/main/java/org/apache/commons/crypto/jna/OpenSsl30XNativeJna.java
new file mode 100644
index 0000000..2b55325
--- /dev/null
+++ b/src/main/java/org/apache/commons/crypto/jna/OpenSsl30XNativeJna.java
@@ -0,0 +1,414 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.commons.crypto.jna;
+
+import java.nio.ByteBuffer;
+
+import org.apache.commons.crypto.Crypto;
+
+import com.sun.jna.Native;
+import com.sun.jna.NativeLong;
+import com.sun.jna.ptr.PointerByReference;
+
+final class OpenSsl30XNativeJna implements OpenSslInterfaceNativeJna {
+
+    static final boolean INIT_OK;
+
+    static final Throwable INIT_ERROR;
+
+    static {
+        OpenSslJna.debug("OpenSsl30XNativeJna static init start");
+        boolean ok = false;
+        Throwable thrown = null;
+        try {
+            final String libName = System.getProperty(Crypto.CONF_PREFIX + OpenSslNativeJna.class.getSimpleName(), "crypto");
+            OpenSslJna.debug("OpenSsl30XNativeJna Native.register('%s')", libName);
+            Native.register(libName);
+            ok = true;
+        } catch (final Exception | UnsatisfiedLinkError e) {
+            thrown = e;
+        } finally {
+            INIT_OK = ok;
+            INIT_ERROR = thrown;
+        }
+        OpenSslJna.debug("OpenSsl30XNativeJna static init end");
+    }
+
+    // Try to keep methods aligned across versions
+
+    /**
+     * Retrieves version/build information about OpenSSL library. This is returned by {@link OpenSslNativeJna#OpenSSLVersion(int)}
+     *
+     * @param type type can be SSLEAY_VERSION, SSLEAY_CFLAGS, SSLEAY_BUILT_ON...
+     * @return A pointer to a constant string describing the version of the OpenSSL library or giving information about the library build.
+     */
+    public static native String OpenSSL_version(int type);
+
+    /**
+     * @return the earliest error code from the thread's error queue without modifying it.
+     */
+    public static native NativeLong ERR_peek_error();
+
+    /**
+     * Generates a human-readable string representing the error code e.
+     *
+     * @see <a href="https://www.openssl.org/docs/man1.0.2/man3/ERR_error_string.html">ERR_error_string</a>
+     *
+     * @param err   the error code
+     * @param null_ buf is NULL, the error string is placed in a static buffer
+     * @return the human-readable error messages.
+     */
+    public static native String ERR_error_string(NativeLong err, char[] null_);
+
+    /**
+     * Creates a cipher context.
+     *
+     * @return a pointer to a newly created EVP_CIPHER_CTX for success and NULL for failure.
+     */
+    public static native PointerByReference EVP_CIPHER_CTX_new();
+
+    /**
+     * Enables or disables padding.
+     *
+     * @param c   cipher context.
+     * @param pad If the pad parameter is zero then no padding is performed.
+     * @return always returns 1
+     */
+    public static native int EVP_CIPHER_CTX_set_padding(PointerByReference c, int pad);
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 128-bit key CBC mode.
+     */
+    public static native PointerByReference EVP_aes_128_cbc();
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 128-bit key CTR mode.
+     */
+    public static native PointerByReference EVP_aes_128_ctr();
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 192-bit key CBC mode.
+     */
+    public static native PointerByReference EVP_aes_192_cbc();
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 192-bit key CTR mode.
+     */
+    public static native PointerByReference EVP_aes_192_ctr();
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 256-bit key CBC mode.
+     */
+    public static native PointerByReference EVP_aes_256_cbc();
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 256-bit key CTR mode.
+     */
+    public static native PointerByReference EVP_aes_256_ctr();
+
+    /**
+     * Init a cipher.
+     *
+     * @param ctx    cipher context
+     * @param cipher evp cipher instance
+     * @param impl   engine
+     * @param key    key
+     * @param iv     iv
+     * @param enc    1 for encryption, 0 for decryption
+     * @return 1 for success and 0 for failure.
+     */
+    public static native int EVP_CipherInit_ex(PointerByReference ctx, PointerByReference cipher, PointerByReference impl, byte[] key, byte[] iv, int enc);
+
+    /**
+     * Continues a multiple-part encryption/decryption operation.
+     *
+     * @param ctx  cipher context
+     * @param bout output byte buffer
+     * @param outl output length
+     * @param in   input byte buffer
+     * @param inl  input length
+     * @return 1 for success and 0 for failure.
+     */
+    public static native int EVP_CipherUpdate(PointerByReference ctx, ByteBuffer bout, int[] outl, ByteBuffer in, int inl);
+
+    /**
+     * Finishes a multiple-part operation.
+     *
+     * @param ctx  cipher context
+     * @param bout output byte buffer
+     * @param outl output length
+     * @return 1 for success and 0 for failure.
+     */
+    public static native int EVP_CipherFinal_ex(PointerByReference ctx, ByteBuffer bout, int[] outl);
+
+    /**
+     * Clears all information from a cipher context and free up any allocated memory associate with it, including ctx itself.
+     *
+     * @param c openssl evp cipher
+     */
+    public static native void EVP_CIPHER_CTX_free(PointerByReference c);
+
+    /**
+     * Clears all information from a cipher context and free up any allocated * memory associate with it.
+     *
+     * @param c openssl evp cipher
+     */
+    public static native void EVP_CIPHER_CTX_reset(PointerByReference c);
+
+    // Random generator
+    /**
+     * OpenSSL uses for random number generation.
+     *
+     * @return pointers to the respective methods.
+     */
+    public static native PointerByReference RAND_get_rand_method();
+
+    /**
+     * OpenSSL uses for random number generation.
+     *
+     * @return pointers to the respective methods.
+     */
+    public static native PointerByReference RAND_OpenSSL();
+
+    /**
+     * Generates random data.
+     *
+     * @param buf the bytes for generated random.
+     * @param num buffer length.
+     * @return 1 on success, 0 otherwise.
+     */
+    public static native int RAND_bytes(ByteBuffer buf, int num);
+
+    // ENGINE API: https://www.openssl.org/docs/man1.0.2/man3/engine.html
+
+    /**
+     * Releases all functional references.
+     *
+     * @param e engine reference.
+     * @return 0 on success, 1 otherwise.
+     */
+    public static native int ENGINE_finish(PointerByReference e);
+
+    /**
+     * Frees the structural reference
+     *
+     * @param e engine reference.
+     * @return 0 on success, 1 otherwise.
+     */
+    public static native int ENGINE_free(PointerByReference e);
+
+    /**
+     * Cleanups before program exit, it will avoid memory leaks.
+     *
+     * @return 0 on success, 1 otherwise.
+     */
+    public static native int OPENSSL_cleanup();
+
+    /**
+     * Obtains a functional reference from an existing structural reference.
+     *
+     * @param e engine reference
+     * @return zero if the ENGINE was not already operational and couldn't be successfully initialized
+     */
+    public static native int ENGINE_init(PointerByReference e);
+
+    public static native void ENGINE_load_builtin_engines();
+
+    /**
+     * Sets the engine as the default for random number generation.
+     *
+     * @param e     engine reference.
+     * @param flags ENGINE_METHOD_RAND.
+     * @return zero if failed.
+     */
+    public static native int ENGINE_set_default(PointerByReference e, int flags);
+
+    /**
+     * Gets engine by id.
+     *
+     * @param id engine id.
+     * @return engine instance
+     */
+    public static native PointerByReference ENGINE_by_id(String id);
+
+    // ================== instance interface methods ==================
+
+    @Override
+    public boolean _INIT_OK() {
+        return INIT_OK;
+    }
+
+    @Override
+    public Throwable _INIT_ERROR() {
+        return INIT_ERROR;
+    }
+
+    @Override
+    public PointerByReference _ENGINE_by_id(final String string) {
+        OpenSslJna.debug("ENGINE_by_id('%s')", string);
+        return debugResult(ENGINE_by_id(string));
+    }
+
+    private <T> T debugResult(T value) {
+        OpenSslJna.debug(" <- %s", value);
+        return value;
+    }
+    @Override
+    public int _ENGINE_finish(final PointerByReference rdrandEngine) {
+        OpenSslJna.debug("ENGINE_finish(%s)", rdrandEngine);
+        return debugResult(ENGINE_finish(rdrandEngine));
+    }
+
+    @Override
+    public int _ENGINE_free(final PointerByReference rdrandEngine) {
+        OpenSslJna.debug("ENGINE_free(%s)", rdrandEngine);
+        return debugResult(ENGINE_free(rdrandEngine));
+    }
+
+    @Override
+    public int _ENGINE_init(final PointerByReference rdrandEngine) {
+        OpenSslJna.debug("ENGINE_init(%s)", rdrandEngine);
+        return debugResult(ENGINE_init(rdrandEngine));
+    }
+
+    @Override
+    public int _ENGINE_set_default(final PointerByReference rdrandEngine, final int flags) {
+        OpenSslJna.debug("ENGINE_set_default(%s, %s)", rdrandEngine, flags);
+        return debugResult(ENGINE_set_default(rdrandEngine, flags));
+    }
+
+    @Override
+    public String _ERR_error_string(final NativeLong err, final char[] buff) {
+        return ERR_error_string(err, buff);
+    }
+
+    @Override
+    public NativeLong _ERR_peek_error() {
+        return ERR_peek_error();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_128_cbc() {
+        return EVP_aes_128_cbc();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_128_ctr() {
+        return EVP_aes_128_ctr();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_192_cbc() {
+        return EVP_aes_192_cbc();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_192_ctr() {
+        return EVP_aes_192_ctr();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_256_cbc() {
+        return EVP_aes_256_cbc();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_256_ctr() {
+        return EVP_aes_256_ctr();
+    }
+
+    @Override
+    public void _EVP_CIPHER_CTX_free(final PointerByReference context) {
+        EVP_CIPHER_CTX_free(context);
+    }
+
+    @Override
+    public PointerByReference _EVP_CIPHER_CTX_new() {
+        return EVP_CIPHER_CTX_new();
+    }
+
+    @Override
+    public int _EVP_CIPHER_CTX_set_padding(final PointerByReference context, final int padding) {
+        return EVP_CIPHER_CTX_set_padding(context, padding);
+    }
+
+    @Override
+    public int _EVP_CipherFinal_ex(final PointerByReference context, final ByteBuffer outBuffer, final int[] outlen) {
+        return EVP_CipherFinal_ex(context, outBuffer, outlen);
+    }
+
+    @Override
+    public int _EVP_CipherInit_ex(final PointerByReference context, final PointerByReference algo, final PointerByReference impl, final byte[] encoded,
+            final byte[] iv, final int cipherMode) {
+        return EVP_CipherInit_ex(context, algo, impl, encoded, iv, cipherMode);
+    }
+
+    @Override
+    public int _EVP_CipherUpdate(final PointerByReference context, final ByteBuffer outBuffer, final int[] outlen, final ByteBuffer inBuffer,
+            final int remaining) {
+        return EVP_CipherUpdate(context, outBuffer, outlen, inBuffer, remaining);
+    }
+
+    @Override
+    public int _RAND_bytes(final ByteBuffer buf, final int length) {
+        return RAND_bytes(buf, length);
+    }
+
+    @Override
+    public PointerByReference _RAND_get_rand_method() {
+        return RAND_get_rand_method();
+    }
+
+    @Override
+    public PointerByReference _RAND_SSLeay() {
+        return RAND_OpenSSL();
+    }
+
+    @Override
+    public String _OpenSSL_version(final int i) {
+        return OpenSSL_version(i);
+    }
+
+    public void _ENGINE_load_builtin_engines() {
+        OpenSslJna.debug("ENGINE_load_builtin_engines()");
+        ENGINE_load_builtin_engines();
+    }
+
+    @Override
+    public void _ENGINE_load_rdrand() {
+        OpenSslJna.debug("ENGINE_load_rdrand() -> ENGINE_load_builtin_engines()");
+        _ENGINE_load_builtin_engines();
+    }
+
+    @Override
+    public int _ENGINE_cleanup() {
+        // Do NOT map this to OPENSSL_cleanup or other APIs will crash like ENGINE_by_id()
+        return 1;
+    }
+
+    public int _OPENSSL_cleanup() {
+        OpenSslJna.debug("OPENSSL_cleanup()");
+        return debugResult(OPENSSL_cleanup());
+    }
+
+    @Override
+    public void _EVP_CIPHER_CTX_cleanup(final PointerByReference context) {
+        EVP_CIPHER_CTX_reset(context);
+    }
+}
diff --git a/src/main/java/org/apache/commons/crypto/jna/OpenSsl31XNativeJna.java b/src/main/java/org/apache/commons/crypto/jna/OpenSsl31XNativeJna.java
new file mode 100644
index 0000000..306026b
--- /dev/null
+++ b/src/main/java/org/apache/commons/crypto/jna/OpenSsl31XNativeJna.java
@@ -0,0 +1,413 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.commons.crypto.jna;
+
+import java.nio.ByteBuffer;
+
+import org.apache.commons.crypto.Crypto;
+
+import com.sun.jna.Native;
+import com.sun.jna.NativeLong;
+import com.sun.jna.ptr.PointerByReference;
+
+final class OpenSsl31XNativeJna implements OpenSslInterfaceNativeJna {
+
+    static final boolean INIT_OK;
+
+    static final Throwable INIT_ERROR;
+
+    static {
+        OpenSslJna.debug("OpenSsl31XNativeJna static init start");
+        boolean ok = false;
+        Throwable thrown = null;
+        try {
+            final String libName = System.getProperty(Crypto.CONF_PREFIX + OpenSslNativeJna.class.getSimpleName(), "crypto");
+            OpenSslJna.debug("OpenSsl30XNativeJna Native.register('%s')", libName);
+            Native.register(libName);
+            ok = true;
+        } catch (final Exception | UnsatisfiedLinkError e) {
+            thrown = e;
+        } finally {
+            INIT_OK = ok;
+            INIT_ERROR = thrown;
+        }
+        OpenSslJna.debug("OpenSsl31XNativeJna static init end");
+    }
+
+    // Try to keep methods aligned across versions
+
+    /**
+     * Retrieves version/build information about OpenSSL library. This is returned by {@link OpenSslNativeJna#OpenSSLVersion(int)}
+     *
+     * @param type type can be SSLEAY_VERSION, SSLEAY_CFLAGS, SSLEAY_BUILT_ON...
+     * @return A pointer to a constant string describing the version of the OpenSSL library or giving information about the library build.
+     */
+    public static native String OpenSSL_version(int type);
+
+    /**
+     * @return the earliest error code from the thread's error queue without modifying it.
+     */
+    public static native NativeLong ERR_peek_error();
+
+    /**
+     * Generates a human-readable string representing the error code e.
+     *
+     * @see <a href="https://www.openssl.org/docs/man1.0.2/man3/ERR_error_string.html">ERR_error_string</a>
+     *
+     * @param err   the error code
+     * @param null_ buf is NULL, the error string is placed in a static buffer
+     * @return the human-readable error messages.
+     */
+    public static native String ERR_error_string(NativeLong err, char[] null_);
+
+    /**
+     * Creates a cipher context.
+     *
+     * @return a pointer to a newly created EVP_CIPHER_CTX for success and NULL for failure.
+     */
+    public static native PointerByReference EVP_CIPHER_CTX_new();
+
+    /**
+     * Enables or disables padding.
+     *
+     * @param c   cipher context.
+     * @param pad If the pad parameter is zero then no padding is performed.
+     * @return always returns 1
+     */
+    public static native int EVP_CIPHER_CTX_set_padding(PointerByReference c, int pad);
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 128-bit key CBC mode.
+     */
+    public static native PointerByReference EVP_aes_128_cbc();
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 128-bit key CTR mode.
+     */
+    public static native PointerByReference EVP_aes_128_ctr();
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 192-bit key CBC mode.
+     */
+    public static native PointerByReference EVP_aes_192_cbc();
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 192-bit key CTR mode.
+     */
+    public static native PointerByReference EVP_aes_192_ctr();
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 256-bit key CBC mode.
+     */
+    public static native PointerByReference EVP_aes_256_cbc();
+
+    /**
+     * @return an OpenSSL AES EVP cipher instance with a 256-bit key CTR mode.
+     */
+    public static native PointerByReference EVP_aes_256_ctr();
+
+    /**
+     * Init a cipher.
+     *
+     * @param ctx    cipher context
+     * @param cipher evp cipher instance
+     * @param impl   engine
+     * @param key    key
+     * @param iv     iv
+     * @param enc    1 for encryption, 0 for decryption
+     * @return 1 for success and 0 for failure.
+     */
+    public static native int EVP_CipherInit_ex(PointerByReference ctx, PointerByReference cipher, PointerByReference impl, byte[] key, byte[] iv, int enc);
+
+    /**
+     * Continues a multiple-part encryption/decryption operation.
+     *
+     * @param ctx  cipher context
+     * @param bout output byte buffer
+     * @param outl output length
+     * @param in   input byte buffer
+     * @param inl  input length
+     * @return 1 for success and 0 for failure.
+     */
+    public static native int EVP_CipherUpdate(PointerByReference ctx, ByteBuffer bout, int[] outl, ByteBuffer in, int inl);
+
+    /**
+     * Finishes a multiple-part operation.
+     *
+     * @param ctx  cipher context
+     * @param bout output byte buffer
+     * @param outl output length
+     * @return 1 for success and 0 for failure.
+     */
+    public static native int EVP_CipherFinal_ex(PointerByReference ctx, ByteBuffer bout, int[] outl);
+
+    /**
+     * Clears all information from a cipher context and free up any allocated memory associate with it, including ctx itself.
+     *
+     * @param c openssl evp cipher
+     */
+    public static native void EVP_CIPHER_CTX_free(PointerByReference c);
+
+    /**
+     * Clears all information from a cipher context and free up any allocated * memory associate with it.
+     *
+     * @param c openssl evp cipher
+     */
+    public static native void EVP_CIPHER_CTX_reset(PointerByReference c);
+
+    // Random generator
+    /**
+     * OpenSSL uses for random number generation.
+     *
+     * @return pointers to the respective methods.
+     */
+    public static native PointerByReference RAND_get_rand_method();
+
+    /**
+     * OpenSSL uses for random number generation.
+     *
+     * @return pointers to the respective methods.
+     */
+    public static native PointerByReference RAND_OpenSSL();
+
+    /**
+     * Generates random data.
+     *
+     * @param buf the bytes for generated random.
+     * @param num buffer length.
+     * @return 1 on success, 0 otherwise.
+     */
+    public static native int RAND_bytes(ByteBuffer buf, int num);
+
+    // ENGINE API: https://www.openssl.org/docs/man1.0.2/man3/engine.html
+
+    /**
+     * Releases all functional references.
+     *
+     * @param e engine reference.
+     * @return 0 on success, 1 otherwise.
+     */
+    public static native int ENGINE_finish(PointerByReference e);
+
+    /**
+     * Frees the structural reference
+     *
+     * @param e engine reference.
+     * @return 0 on success, 1 otherwise.
+     */
+    public static native int ENGINE_free(PointerByReference e);
+
+    /**
+     * Cleanups before program exit, it will avoid memory leaks.
+     *
+     * @return 0 on success, 1 otherwise.
+     */
+    public static native int OPENSSL_cleanup();
+
+    /**
+     * Obtains a functional reference from an existing structural reference.
+     *
+     * @param e engine reference
+     * @return zero if the ENGINE was not already operational and couldn't be successfully initialized
+     */
+    public static native int ENGINE_init(PointerByReference e);
+
+    public static native void ENGINE_load_builtin_engines();
+
+    /**
+     * Sets the engine as the default for random number generation.
+     *
+     * @param e     engine reference.
+     * @param flags ENGINE_METHOD_RAND.
+     * @return zero if failed.
+     */
+    public static native int ENGINE_set_default(PointerByReference e, int flags);
+
+    /**
+     * Gets engine by id.
+     *
+     * @param id engine id.
+     * @return engine instance
+     */
+    public static native PointerByReference ENGINE_by_id(String id);
+
+    // ================== instance interface methods ==================
+
+    @Override
+    public boolean _INIT_OK() {
+        return INIT_OK;
+    }
+
+    @Override
+    public Throwable _INIT_ERROR() {
+        return INIT_ERROR;
+    }
+
+    @Override
+    public PointerByReference _ENGINE_by_id(final String string) {
+        OpenSslJna.debug("ENGINE_by_id('%s')", string);
+        return debugResult(ENGINE_by_id(string));
+    }
+
+    private <T> T debugResult(T value) {
+        OpenSslJna.debug(" <- %s", value);
+        return value;
+    }
+    @Override
+    public int _ENGINE_finish(final PointerByReference rdrandEngine) {
+        OpenSslJna.debug("ENGINE_finish(%s)", rdrandEngine);
+        return debugResult(ENGINE_finish(rdrandEngine));
+    }
+
+    @Override
+    public int _ENGINE_free(final PointerByReference rdrandEngine) {
+        OpenSslJna.debug("ENGINE_free(%s)", rdrandEngine);
+        return debugResult(ENGINE_free(rdrandEngine));
+    }
+
+    @Override
+    public int _ENGINE_init(final PointerByReference rdrandEngine) {
+        OpenSslJna.debug("ENGINE_init(%s)", rdrandEngine);
+        return debugResult(ENGINE_init(rdrandEngine));
+    }
+
+    @Override
+    public int _ENGINE_set_default(final PointerByReference rdrandEngine, final int flags) {
+        OpenSslJna.debug("ENGINE_set_default(%s, %s)", rdrandEngine, flags);
+        return debugResult(ENGINE_set_default(rdrandEngine, flags));
+    }
+
+    @Override
+    public String _ERR_error_string(final NativeLong err, final char[] buff) {
+        return ERR_error_string(err, buff);
+    }
+
+    @Override
+    public NativeLong _ERR_peek_error() {
+        return ERR_peek_error();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_128_cbc() {
+        return EVP_aes_128_cbc();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_128_ctr() {
+        return EVP_aes_128_ctr();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_192_cbc() {
+        return EVP_aes_192_cbc();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_192_ctr() {
+        return EVP_aes_192_ctr();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_256_cbc() {
+        return EVP_aes_256_cbc();
+    }
+
+    @Override
+    public PointerByReference _EVP_aes_256_ctr() {
+        return EVP_aes_256_ctr();
+    }
+
+    @Override
+    public void _EVP_CIPHER_CTX_free(final PointerByReference context) {
+        EVP_CIPHER_CTX_free(context);
+    }
+
+    @Override
+    public PointerByReference _EVP_CIPHER_CTX_new() {
+        return EVP_CIPHER_CTX_new();
+    }
+
+    @Override
+    public int _EVP_CIPHER_CTX_set_padding(final PointerByReference context, final int padding) {
+        return EVP_CIPHER_CTX_set_padding(context, padding);
+    }
+
+    @Override
+    public int _EVP_CipherFinal_ex(final PointerByReference context, final ByteBuffer outBuffer, final int[] outlen) {
+        return EVP_CipherFinal_ex(context, outBuffer, outlen);
+    }
+
+    @Override
+    public int _EVP_CipherInit_ex(final PointerByReference context, final PointerByReference algo, final PointerByReference impl, final byte[] encoded,
+            final byte[] iv, final int cipherMode) {
+        return EVP_CipherInit_ex(context, algo, impl, encoded, iv, cipherMode);
+    }
+
+    @Override
+    public int _EVP_CipherUpdate(final PointerByReference context, final ByteBuffer outBuffer, final int[] outlen, final ByteBuffer inBuffer,
+            final int remaining) {
+        return EVP_CipherUpdate(context, outBuffer, outlen, inBuffer, remaining);
+    }
+
+    @Override
+    public int _RAND_bytes(final ByteBuffer buf, final int length) {
+        return RAND_bytes(buf, length);
+    }
+
+    @Override
+    public PointerByReference _RAND_get_rand_method() {
+        return RAND_get_rand_method();
+    }
+
+    @Override
+    public PointerByReference _RAND_SSLeay() {
+        return RAND_OpenSSL();
+    }
+
+    @Override
+    public String _OpenSSL_version(final int i) {
+        return OpenSSL_version(i);
+    }
+
+    public void _ENGINE_load_builtin_engines() {
+        OpenSslJna.debug("ENGINE_load_builtin_engines()");
+        ENGINE_load_builtin_engines();
+    }
+
+    @Override
+    public void _ENGINE_load_rdrand() {
+        // not available
+    }
+
+    @Override
+    public int _ENGINE_cleanup() {
+        // Do NOT map this to OPENSSL_cleanup or other APIs will crash like ENGINE_by_id()
+        return 1;
+    }
+
+    public int _OPENSSL_cleanup() {
+        OpenSslJna.debug("OPENSSL_cleanup()");
+        return debugResult(OPENSSL_cleanup());
+    }
+
+    @Override
+    public void _EVP_CIPHER_CTX_cleanup(final PointerByReference context) {
+        EVP_CIPHER_CTX_reset(context);
+    }
+}
diff --git a/src/main/java/org/apache/commons/crypto/jna/OpenSslNativeJna.java b/src/main/java/org/apache/commons/crypto/jna/OpenSslNativeJna.java
index ccd87a6..9f186c7 100644
--- a/src/main/java/org/apache/commons/crypto/jna/OpenSslNativeJna.java
+++ b/src/main/java/org/apache/commons/crypto/jna/OpenSslNativeJna.java
@@ -48,6 +48,7 @@ final class OpenSslNativeJna {
     static final long VERSION_1_1_X = 0x10100000;
     static final long VERSION_2_0_X = 0x20000000;
     static final long VERSION_3_0_X = 0x30000000;
+    static final long VERSION_3_1_X = 0x30100000;
 
     private static final OpenSslInterfaceNativeJna JnaImplementation;
 
@@ -79,9 +80,12 @@ final class OpenSslNativeJna {
         } else if (VERSION_X_Y == VERSION_2_0_X) {
             OpenSslJna.debug("Creating OpenSsl20XNativeJna");
             JnaImplementation = new OpenSsl20XNativeJna();
-//        } else if (VERSION_X_Y == VERSION_3_0_X) {
-//            OpenSslJna.debug("Creating OpenSsl30XNativeJna");
-//            JnaImplementation = new OpenSsl30XNativeJna();
+        } else if (VERSION_X_Y == VERSION_3_0_X) {
+            OpenSslJna.debug("Creating OpenSsl30XNativeJna");
+            JnaImplementation = new OpenSsl30XNativeJna();
+        } else if (VERSION_X_Y == VERSION_3_1_X) {
+            OpenSslJna.debug("Creating OpenSsl31XNativeJna");
+            JnaImplementation = new OpenSsl31XNativeJna();
         } else {
             // TODO: Throw error?
             OpenSslJna.debug("Creating OpenSsl10XNativeJna");
diff --git a/src/main/native/org/apache/commons/crypto/cipher/OpenSsl3Native.c b/src/main/native/org/apache/commons/crypto/cipher/OpenSsl3Native.c
new file mode 100644
index 0000000..662a549
--- /dev/null
+++ b/src/main/native/org/apache/commons/crypto/cipher/OpenSsl3Native.c
@@ -0,0 +1,734 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "org_apache_commons_crypto.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+// export the native interfaces
+#ifdef JNIEXPORT
+#undef JNIEXPORT
+#endif
+#define JNIEXPORT __attribute__((__visibility__("default")))
+#include "org_apache_commons_crypto_cipher_OpenSsl3Native.h"
+
+#ifdef UNIX
+static EVP_CIPHER_CTX * (*dlsym_EVP_CIPHER_CTX_new)(void);
+static void (*dlsym_EVP_CIPHER_CTX_free)(EVP_CIPHER_CTX *);
+static int (*dlsym_EVP_CIPHER_CTX_set_padding)(EVP_CIPHER_CTX *, int);
+static int (*dlsym_EVP_CIPHER_CTX_ctrl)(EVP_CIPHER_CTX *, int, int, void *);
+static int (*dlsym_EVP_CIPHER_CTX_get_block_size)(EVP_CIPHER_CTX *);
+static EVP_CIPHER * (*dlsym_EVP_CIPHER_CTX_cipher)(EVP_CIPHER_CTX *);
+static unsigned long (*dlsym_EVP_CIPHER_get_flags)(const EVP_CIPHER *);
+static int (*dlsym_EVP_CIPHER_CTX_test_flags)(const EVP_CIPHER_CTX *, int);
+static int (*dlsym_EVP_CipherInit_ex)(EVP_CIPHER_CTX *, const EVP_CIPHER *,  \
+           ENGINE *, const unsigned char *, const unsigned char *, int);
+static int (*dlsym_EVP_CipherUpdate)(EVP_CIPHER_CTX *, unsigned char *,  \
+           int *, const unsigned char *, int);
+static int (*dlsym_EVP_CipherFinal_ex)(EVP_CIPHER_CTX *, unsigned char *, int *);
+static EVP_CIPHER * (*dlsym_EVP_aes_256_ctr)(void);
+static EVP_CIPHER * (*dlsym_EVP_aes_192_ctr)(void);
+static EVP_CIPHER * (*dlsym_EVP_aes_128_ctr)(void);
+static EVP_CIPHER * (*dlsym_EVP_aes_256_cbc)(void);
+static EVP_CIPHER * (*dlsym_EVP_aes_192_cbc)(void);
+static EVP_CIPHER * (*dlsym_EVP_aes_128_cbc)(void);
+static EVP_CIPHER * (*dlsym_EVP_aes_256_gcm)(void);
+static EVP_CIPHER * (*dlsym_EVP_aes_192_gcm)(void);
+static EVP_CIPHER * (*dlsym_EVP_aes_128_gcm)(void);
+#endif
+
+#ifdef WINDOWS
+typedef EVP_CIPHER_CTX * (__cdecl *__dlsym_EVP_CIPHER_CTX_new)(void);
+typedef void (__cdecl *__dlsym_EVP_CIPHER_CTX_free)(EVP_CIPHER_CTX *);
+typedef int (__cdecl *__dlsym_EVP_CIPHER_CTX_set_padding)(EVP_CIPHER_CTX *, int);
+typedef int (__cdecl *__dlsym_EVP_CIPHER_CTX_ctrl)(EVP_CIPHER_CTX *, int, int, void *);
+typedef int (__cdecl *__dlsym_EVP_CIPHER_CTX_get_block_size)(EVP_CIPHER_CTX *);
+typedef EVP_CIPHER * (__cdecl *__dlsym_EVP_CIPHER_CTX_cipher)(EVP_CIPHER_CTX *);
+typedef unsigned long (__cdecl *__dlsym_EVP_CIPHER_get_flags)(const EVP_CIPHER *);
+typedef int (__cdecl *__dlsym_EVP_CIPHER_CTX_test_flags)(const EVP_CIPHER_CTX *, int);
+typedef int (__cdecl *__dlsym_EVP_CipherInit_ex)(EVP_CIPHER_CTX *,  \
+             const EVP_CIPHER *, ENGINE *, const unsigned char *,  \
+             const unsigned char *, int);
+typedef int (__cdecl *__dlsym_EVP_CipherUpdate)(EVP_CIPHER_CTX *,  \
+             unsigned char *, int *, const unsigned char *, int);
+typedef int (__cdecl *__dlsym_EVP_CipherFinal_ex)(EVP_CIPHER_CTX *,  \
+             unsigned char *, int *);
+typedef EVP_CIPHER * (__cdecl *__dlsym_EVP_aes_256_ctr)(void);
+typedef EVP_CIPHER * (__cdecl *__dlsym_EVP_aes_192_ctr)(void);
+typedef EVP_CIPHER * (__cdecl *__dlsym_EVP_aes_128_ctr)(void);
+typedef EVP_CIPHER * (__cdecl *__dlsym_EVP_aes_256_cbc)(void);
+typedef EVP_CIPHER * (__cdecl *__dlsym_EVP_aes_192_cbc)(void);
+typedef EVP_CIPHER * (__cdecl *__dlsym_EVP_aes_128_cbc)(void);
+typedef EVP_CIPHER * (__cdecl *__dlsym_EVP_aes_256_gcm)(void);
+typedef EVP_CIPHER * (__cdecl *__dlsym_EVP_aes_192_gcm)(void);
+typedef EVP_CIPHER * (__cdecl *__dlsym_EVP_aes_128_gcm)(void);
+static __dlsym_EVP_CIPHER_CTX_new dlsym_EVP_CIPHER_CTX_new;
+static __dlsym_EVP_CIPHER_CTX_free dlsym_EVP_CIPHER_CTX_free;
+static __dlsym_EVP_CIPHER_CTX_set_padding dlsym_EVP_CIPHER_CTX_set_padding;
+static __dlsym_EVP_CIPHER_CTX_ctrl dlsym_EVP_CIPHER_CTX_ctrl;
+static __dlsym_EVP_CIPHER_CTX_get_block_size dlsym_EVP_CIPHER_CTX_get_block_size;
+static __dlsym_EVP_CIPHER_CTX_cipher dlsym_EVP_CIPHER_CTX_cipher;
+static __dlsym_EVP_CIPHER_get_flags dlsym_EVP_CIPHER_get_flags;
+static __dlsym_EVP_CIPHER_CTX_test_flags dlsym_EVP_CIPHER_CTX_test_flags;
+static __dlsym_EVP_CipherInit_ex dlsym_EVP_CipherInit_ex;
+static __dlsym_EVP_CipherUpdate dlsym_EVP_CipherUpdate;
+static __dlsym_EVP_CipherFinal_ex dlsym_EVP_CipherFinal_ex;
+static __dlsym_EVP_aes_256_ctr dlsym_EVP_aes_256_ctr;
+static __dlsym_EVP_aes_192_ctr dlsym_EVP_aes_192_ctr;
+static __dlsym_EVP_aes_128_ctr dlsym_EVP_aes_128_ctr;
+static __dlsym_EVP_aes_256_cbc dlsym_EVP_aes_256_cbc;
+static __dlsym_EVP_aes_192_cbc dlsym_EVP_aes_192_cbc;
+static __dlsym_EVP_aes_128_cbc dlsym_EVP_aes_128_cbc;
+static __dlsym_EVP_aes_256_gcm dlsym_EVP_aes_256_gcm;
+static __dlsym_EVP_aes_192_gcm dlsym_EVP_aes_192_gcm;
+static __dlsym_EVP_aes_128_gcm dlsym_EVP_aes_128_gcm;
+#endif
+
+#ifdef UNIX
+static void loadAes(JNIEnv *env, void *openssl)
+#endif
+
+#ifdef WINDOWS
+static void loadAes(JNIEnv *env, HMODULE openssl)
+#endif
+{
+#ifdef UNIX
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_aes_256_ctr, env, openssl, "EVP_aes_256_ctr");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_aes_192_ctr, env, openssl, "EVP_aes_192_ctr");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_aes_128_ctr, env, openssl, "EVP_aes_128_ctr");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_aes_256_cbc, env, openssl, "EVP_aes_256_cbc");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_aes_192_cbc, env, openssl, "EVP_aes_192_cbc");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_aes_128_cbc, env, openssl, "EVP_aes_128_cbc");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_aes_256_gcm, env, openssl, "EVP_aes_256_gcm");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_aes_192_gcm, env, openssl, "EVP_aes_192_gcm");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_aes_128_gcm, env, openssl, "EVP_aes_128_gcm");
+#endif
+
+#ifdef WINDOWS
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_aes_256_ctr, dlsym_EVP_aes_256_ctr,  \
+                      env, openssl, "EVP_aes_256_ctr");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_aes_192_ctr, dlsym_EVP_aes_192_ctr,  \
+                      env, openssl, "EVP_aes_192_ctr");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_aes_128_ctr, dlsym_EVP_aes_128_ctr,  \
+                      env, openssl, "EVP_aes_128_ctr");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_aes_256_cbc, dlsym_EVP_aes_256_cbc,  \
+                      env, openssl, "EVP_aes_256_cbc");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_aes_192_cbc, dlsym_EVP_aes_192_cbc,  \
+                      env, openssl, "EVP_aes_192_cbc");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_aes_128_cbc, dlsym_EVP_aes_128_cbc,  \
+                      env, openssl, "EVP_aes_128_cbc");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_aes_256_gcm, dlsym_EVP_aes_256_gcm,  \
+                      env, openssl, "EVP_aes_256_gcm");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_aes_192_gcm, dlsym_EVP_aes_192_gcm,  \
+                      env, openssl, "EVP_aes_192_gcm");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_aes_128_gcm, dlsym_EVP_aes_128_gcm,  \
+                      env, openssl, "EVP_aes_128_gcm");
+#endif
+}
+
+JNIEXPORT void JNICALL Java_org_apache_commons_crypto_cipher_OpenSsl3Native_initIDs
+    (JNIEnv *env, jclass clazz)
+{
+  char msg[1000];
+#ifdef UNIX
+  void *openssl = open_library(env);
+#endif
+
+#ifdef WINDOWS
+  HMODULE openssl = open_library(env);
+#endif
+
+  if (!openssl) {
+#ifdef UNIX
+    snprintf(msg, sizeof(msg), "Cannot load %s (%s)!", COMMONS_CRYPTO_OPENSSL_LIBRARY,  \
+    dlerror());
+#endif
+#ifdef WINDOWS
+    snprintf(msg, sizeof(msg), "Cannot load %s (%d)!", COMMONS_CRYPTO_OPENSSL_LIBRARY,  \
+    GetLastError());
+#endif
+    THROW(env, "java/lang/UnsatisfiedLinkError", msg);
+    return;
+  }
+
+#ifdef UNIX
+  dlerror();  // Clear any existing error
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CIPHER_CTX_new, env, openssl, "EVP_CIPHER_CTX_new");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CIPHER_CTX_free, env, openssl, "EVP_CIPHER_CTX_free");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CIPHER_CTX_set_padding, env, openssl, "EVP_CIPHER_CTX_set_padding");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CIPHER_CTX_ctrl, env, openssl, "EVP_CIPHER_CTX_ctrl");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CIPHER_CTX_get_block_size, env, openssl, "EVP_CIPHER_CTX_get_block_size");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CIPHER_CTX_cipher, env, openssl, "EVP_CIPHER_CTX_cipher");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CIPHER_get_flags, env, openssl, "EVP_CIPHER_get_flags");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CIPHER_CTX_test_flags, env, openssl, "EVP_CIPHER_CTX_test_flags");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CipherInit_ex, env, openssl, "EVP_CipherInit_ex");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CipherUpdate, env, openssl, "EVP_CipherUpdate");
+  LOAD_DYNAMIC_SYMBOL(dlsym_EVP_CipherFinal_ex, env, openssl, "EVP_CipherFinal_ex");
+#endif
+
+#ifdef WINDOWS
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CIPHER_CTX_new, dlsym_EVP_CIPHER_CTX_new,  \
+                      env, openssl, "EVP_CIPHER_CTX_new");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CIPHER_CTX_free, dlsym_EVP_CIPHER_CTX_free,  \
+                      env, openssl, "EVP_CIPHER_CTX_free");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CIPHER_CTX_set_padding, dlsym_EVP_CIPHER_CTX_set_padding,  \
+                      env, openssl, "EVP_CIPHER_CTX_set_padding");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CIPHER_CTX_ctrl, dlsym_EVP_CIPHER_CTX_ctrl,  \
+                      env, openssl, "EVP_CIPHER_CTX_ctrl");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CIPHER_CTX_get_block_size, dlsym_EVP_CIPHER_CTX_get_block_size,  \
+                      env, openssl, "EVP_CIPHER_CTX_get_block_size");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CIPHER_CTX_cipher, dlsym_EVP_CIPHER_CTX_cipher,  \
+                      env, openssl, "EVP_CIPHER_CTX_cipher");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CIPHER_get_flags, dlsym_EVP_CIPHER_get_flags,  \
+                      env, openssl, "EVP_CIPHER_get_flags");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CIPHER_CTX_test_flags, dlsym_EVP_CIPHER_CTX_test_flags,  \
+                      env, openssl, "EVP_CIPHER_CTX_test_flags");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CipherInit_ex, dlsym_EVP_CipherInit_ex,  \
+                      env, openssl, "EVP_CipherInit_ex");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CipherUpdate, dlsym_EVP_CipherUpdate,  \
+                      env, openssl, "EVP_CipherUpdate");
+  LOAD_DYNAMIC_SYMBOL(__dlsym_EVP_CipherFinal_ex, dlsym_EVP_CipherFinal_ex,  \
+                      env, openssl, "EVP_CipherFinal_ex");
+#endif
+
+  loadAes(env, openssl);
+  jthrowable jthr = (*env)->ExceptionOccurred(env);
+  if (jthr) {
+    (*env)->DeleteLocalRef(env, jthr);
+    THROW(env, "java/lang/UnsatisfiedLinkError",  \
+    "Cannot find AES-CTR support, is your version of Openssl new enough?");
+    return;
+  }
+}
+
+typedef struct EVP_CTX_Wrapper {
+  int initialized;
+  int encrypt; // ENCRYPT_MODE or DECRYPT_MODE
+  EVP_CIPHER_CTX *ctx;
+} EVP_CTX_Wrapper;
+
+static int check_update_max_output_len(EVP_CTX_Wrapper *wrapper, int input_len, int max_output_len);
+static int check_doFinal_max_output_len(JNIEnv *env, EVP_CIPHER_CTX *context, int max_output_len);
+static int is_bad_tag(EVP_CTX_Wrapper *wrapper);
+
+#define CTX_WRAPPER(addr) ((EVP_CTX_Wrapper *)(ptrdiff_t) addr)
+
+static EVP_CTX_Wrapper * new_context_wrapper(JNIEnv *env) {
+  EVP_CTX_Wrapper *wrapper = calloc(1, sizeof(EVP_CTX_Wrapper));
+  if (wrapper == NULL) {
+    THROW(env, "java/lang/OutOfMemoryError", NULL);
+    return NULL;
+  }
+
+  wrapper->ctx = dlsym_EVP_CIPHER_CTX_new();
+  if (wrapper->ctx == NULL) {
+    free(wrapper);
+    wrapper = NULL;
+
+    THROW(env, "java/lang/OutOfMemoryError", NULL);
+    return NULL;
+  }
+
+  return wrapper;
+}
+
+static void free_context_wrapper(EVP_CTX_Wrapper *wrapper) {
+  if (wrapper != NULL) {
+    if (wrapper->ctx != NULL) {
+      dlsym_EVP_CIPHER_CTX_free(wrapper->ctx);
+    }
+    free(wrapper);
+  }
+}
+
+static EVP_CIPHER_CTX * get_context(JNIEnv *env, jlong addr) {
+  EVP_CTX_Wrapper *wrapper = CTX_WRAPPER(addr);
+  if (wrapper == NULL || wrapper->ctx == NULL) {
+    THROW(env, "java/lang/NullPointerException", "Context address is null.");
+    return NULL;
+  }
+
+  if (!wrapper->initialized) {
+    THROW(env, "java/lang/IllegalStateException", "Context is not initialized.");
+    return NULL;
+  }
+
+  return wrapper->ctx;
+}
+
+JNIEXPORT jlong JNICALL Java_org_apache_commons_crypto_cipher_OpenSsl3Native_initContext
+    (JNIEnv *env, jclass clazz, jint alg, jint padding)
+{
+  if (alg != AES_CTR && alg != AES_CBC && alg != AES_GCM) {
+    THROW(env, "java/security/NoSuchAlgorithmException", NULL);
+    return (jlong)0;
+  }
+  if (!(alg == AES_CTR && padding == NOPADDING)
+      && !(alg == AES_CBC && (padding == NOPADDING|| padding == PKCS5PADDING))
+      && !(alg == AES_GCM && padding == NOPADDING)) {
+    THROW(env, "javax/crypto/NoSuchPaddingException", NULL);
+    return (jlong)0;
+  }
+
+  if (dlsym_EVP_aes_256_ctr == NULL ||
+      dlsym_EVP_aes_192_ctr == NULL || dlsym_EVP_aes_128_ctr == NULL) {
+    THROW(env, "java/security/NoSuchAlgorithmException",  \
+    "Doesn't support AES CTR.");
+    return (jlong)0;
+  }
+
+  if (dlsym_EVP_aes_256_cbc == NULL ||
+      dlsym_EVP_aes_192_cbc == NULL || dlsym_EVP_aes_128_cbc == NULL) {
+    THROW(env, "java/security/NoSuchAlgorithmException",  \
+    "Doesn't support AES CBC.");
+    return (jlong)0;
+  }
+
+  if (dlsym_EVP_aes_256_gcm == NULL ||
+      dlsym_EVP_aes_192_gcm == NULL || dlsym_EVP_aes_128_gcm == NULL) {
+    THROW(env, "java/security/NoSuchAlgorithmException",  \
+    "Doesn't support AES GCM.");
+    return (jlong)0;
+  }
+
+  EVP_CTX_Wrapper *wrapper = new_context_wrapper(env);
+  return JLONG(wrapper);
+}
+
+// Only supports AES-CTR and AES-CBC currently
+static EVP_CIPHER * getEvpCipher(int alg, int keyLen)
+{
+  EVP_CIPHER *cipher = NULL;
+  if (alg == AES_CTR) {
+    if (keyLen == KEY_LENGTH_256) {
+      cipher = dlsym_EVP_aes_256_ctr();
+    } else if (keyLen == KEY_LENGTH_192) {
+      cipher = dlsym_EVP_aes_192_ctr();
+    } else if (keyLen == KEY_LENGTH_128) {
+      cipher = dlsym_EVP_aes_128_ctr();
+    }
+  } else if (alg == AES_CBC) {
+    if (keyLen == KEY_LENGTH_256) {
+      cipher = dlsym_EVP_aes_256_cbc();
+    } else if (keyLen == KEY_LENGTH_192) {
+      cipher = dlsym_EVP_aes_192_cbc();
+    } else if (keyLen == KEY_LENGTH_128) {
+      cipher = dlsym_EVP_aes_128_cbc();
+    }
+  } else if (alg == AES_GCM) {
+    if (keyLen == KEY_LENGTH_256) {
+      cipher = dlsym_EVP_aes_256_gcm();
+    } else if (keyLen == KEY_LENGTH_192) {
+      cipher = dlsym_EVP_aes_192_gcm();
+    } else if (keyLen == KEY_LENGTH_128) {
+      cipher = dlsym_EVP_aes_128_gcm();
+    }
+  }
+  return cipher;
+}
+
+JNIEXPORT jlong JNICALL Java_org_apache_commons_crypto_cipher_OpenSsl3Native_init
+  (JNIEnv *env, jclass clazz, jlong ctx, jint mode, jint alg, jint padding,
+   jbyteArray key, jbyteArray iv)
+{
+  EVP_CTX_Wrapper *wrapper = CTX_WRAPPER(ctx);
+  int is_new_context = 0;
+  if (wrapper == NULL) {
+    wrapper = new_context_wrapper(env);
+    if (wrapper == NULL) {
+      return JLONG(NULL);
+    }
+    is_new_context = 1;
+  }
+
+  EVP_CIPHER_CTX *context = wrapper->ctx;
+  jbyte *jKey = NULL;
+  jbyte *jIv  = NULL;
+  int jKeyLen = (*env)->GetArrayLength(env, key);
+  int jIvLen = (*env)->GetArrayLength(env, iv);
+  if (jKeyLen != KEY_LENGTH_128 && jKeyLen != KEY_LENGTH_192
+      && jKeyLen != KEY_LENGTH_256) {
+    char str[64] = {0};
+    snprintf(str, sizeof(str), "Invalid AES key length: %d bytes", jKeyLen);
+    THROW(env, "java/security/InvalidKeyException", str);
+    goto cleanup;
+  }
+  if ((alg != AES_GCM) && (jIvLen != IV_LENGTH)) {
+    THROW(env, "java/security/InvalidAlgorithmParameterException", "Wrong IV length: must be 16 bytes long");
+    goto cleanup;
+  }
+
+  jKey = (*env)->GetByteArrayElements(env, key, NULL);
+  if (jKey == NULL) {
+    THROW(env, "java/lang/InternalError", "Cannot get bytes array for key.");
+    goto cleanup;
+  }
+  jIv = (*env)->GetByteArrayElements(env, iv, NULL);
+  if (jIv == NULL) {
+    THROW(env, "java/lang/InternalError", "Cannot get bytes array for iv.");
+    goto cleanup;
+  }
+
+  if (!(alg == AES_CTR || alg == AES_CBC || alg == AES_GCM)) {
+    THROW(env, "java/security/NoSuchAlgorithmException", "The algorithm is not supported.");
+    goto cleanup;
+  }
+
+  // initialize cipher & mode
+  EVP_CIPHER *cipher = getEvpCipher(alg, jKeyLen);
+  if (cipher == NULL) {
+    THROW(env, "java/security/InvalidKeyException", "Invalid key length.");
+    goto cleanup;
+  }
+
+  int rc = dlsym_EVP_CipherInit_ex(context, cipher, NULL, NULL, NULL, mode == ENCRYPT_MODE);
+  if (rc == 0) {
+    THROW(env, "java/lang/InternalError", "Error in EVP_CipherInit_ex.");
+    goto cleanup;
+  }
+
+  // Set IV length if default 12 bytes (96 bits) is not appropriate
+  // Note: set IV length after cipher is initialized, before iv is initialized.
+  if (alg == AES_GCM) {
+    rc = dlsym_EVP_CIPHER_CTX_ctrl(context, EVP_CTRL_GCM_SET_IVLEN, jIvLen, NULL);
+    if (rc == 0) {
+      THROW(env, "java/lang/InternalError", "Error setting GCM initial vector length.");
+      goto cleanup;
+    }
+  }
+
+  rc = dlsym_EVP_CipherInit_ex(context, NULL, NULL, \
+       (unsigned char *)jKey, (unsigned char *)jIv, mode == ENCRYPT_MODE);
+  if (rc == 0) {
+    THROW(env, "java/lang/InternalError", "Error in EVP_CipherInit_ex.");
+    goto cleanup;
+  }
+
+  if (padding == NOPADDING) {
+    dlsym_EVP_CIPHER_CTX_set_padding(context, 0);
+  } else if (padding == PKCS5PADDING) {
+    dlsym_EVP_CIPHER_CTX_set_padding(context, 1);
+  }
+
+  // everything is OK,
+  wrapper->encrypt = mode;
+  wrapper->initialized = 1;
+
+cleanup:
+  if (jKey != NULL) {
+    (*env)->ReleaseByteArrayElements(env, key, jKey, 0);
+  }
+  if (jIv != NULL) {
+    (*env)->ReleaseByteArrayElements(env, iv, jIv, 0);
+  }
+  if (is_new_context && !wrapper->initialized) {
+    free_context_wrapper(wrapper);
+    wrapper = NULL;
+  }
+  return JLONG(wrapper);
+}
+
+JNIEXPORT jint JNICALL Java_org_apache_commons_crypto_cipher_OpenSsl3Native_update
+  (JNIEnv *env, jclass clazz, jlong ctx, jobject input, jint input_offset,
+   jint input_len, jobject output, jint output_offset, jint max_output_len)
+{
+  EVP_CIPHER_CTX *context = get_context(env, ctx);
+  if (context == NULL) {
+    return 0;
+  }
+
+  if (!check_update_max_output_len(CTX_WRAPPER(ctx), input_len, max_output_len)) {
+    THROW(env, "javax/crypto/ShortBufferException",  \
+    "Output buffer is not sufficient.");
+    return 0;
+  }
+  unsigned char *input_bytes = (*env)->GetDirectBufferAddress(env, input);
+  unsigned char *output_bytes = (*env)->GetDirectBufferAddress(env, output);
+  if (input_bytes == NULL || output_bytes == NULL) {
+    THROW(env, "java/lang/InternalError", "Cannot get buffer address.");
+    return 0;
+  }
+  input_bytes = input_bytes + input_offset;
+  output_bytes = output_bytes + output_offset;
+
+  int output_len = 0;
+  if (!dlsym_EVP_CipherUpdate(context, output_bytes, &output_len,  \
+      input_bytes, input_len)) {
+    THROW(env, "java/lang/InternalError", "Error in EVP_CipherUpdate.");
+    return 0;
+  }
+  return output_len;
+}
+
+JNIEXPORT jint JNICALL Java_org_apache_commons_crypto_cipher_OpenSsl3Native_updateByteArray
+  (JNIEnv *env, jclass clazz, jlong ctx, jbyteArray input, jint input_offset,
+   jint input_len, jbyteArray output, jint output_offset, jint max_output_len)
+{
+  EVP_CIPHER_CTX *context = get_context(env, ctx);
+  if (context == NULL) {
+    return 0;
+  }
+
+  // when provide AAD to EVP cipher, output is NULL.
+  if (output != NULL && !check_update_max_output_len(CTX_WRAPPER(ctx), input_len, max_output_len)) {
+    THROW(env, "javax/crypto/ShortBufferException", "Output buffer is not sufficient.");
+    return 0;
+  }
+
+  unsigned char *input_bytes = NULL;
+  unsigned char *output_bytes = NULL;
+  int output_len = 0;
+
+  input_bytes = (unsigned char *) (*env)->GetByteArrayElements(env, input, 0);
+
+  // output is NULL when updateAAD
+  if (output != NULL) {
+    output_bytes = (unsigned char *) (*env)->GetByteArrayElements(env, output, 0);
+  }
+  if (input_bytes == NULL || (output != NULL && output_bytes == NULL)) {
+    THROW(env, "java/lang/InternalError", "Cannot get buffer address.");
+    goto cleanup;
+  }
+
+  int rc = dlsym_EVP_CipherUpdate(context, output_bytes + output_offset, &output_len,  \
+      input_bytes + input_offset, input_len);
+  if (rc == 0) {
+    THROW(env, "java/lang/InternalError", "Error in EVP_CipherUpdate.");
+    output_len = 0;
+  }
+
+cleanup:
+  if (input_bytes != NULL) {
+    (*env)->ReleaseByteArrayElements(env, input, (jbyte *) input_bytes, 0);
+  }
+  if (output_bytes != NULL) {
+    (*env)->ReleaseByteArrayElements(env, output, (jbyte *) output_bytes, 0);
+  }
+
+  return output_len;
+}
+
+JNIEXPORT jint JNICALL Java_org_apache_commons_crypto_cipher_OpenSsl3Native_updateByteArrayByteBuffer
+  (JNIEnv *env, jclass clazz, jlong ctx, jbyteArray input, jint input_offset,
+   jint input_len, jobject output, jint output_offset, jint max_output_len)
+{
+  EVP_CIPHER_CTX *context = get_context(env, ctx);
+  if (context == NULL) {
+    return 0;
+  }
+
+  if (!check_update_max_output_len(CTX_WRAPPER(ctx), input_len, max_output_len)) {
+    THROW(env, "javax/crypto/ShortBufferException",  \
+    "Output buffer is not sufficient.");
+    return 0;
+  }
+
+  unsigned char *input_bytes = (unsigned char *) (*env)->GetByteArrayElements(env, input, 0);
+  unsigned char *output_bytes = (*env)->GetDirectBufferAddress(env, output);
+  int output_len = 0;
+
+  if (input_bytes == NULL || output_bytes == NULL) {
+    THROW(env, "java/lang/InternalError", "Cannot get buffer address.");
+    goto cleanup;
+  }
+
+  int rc = dlsym_EVP_CipherUpdate(context, output_bytes + output_offset, &output_len,
+      input_bytes + input_offset, input_len);
+  if (rc == 0) {
+    THROW(env, "java/lang/InternalError", "Error in EVP_CipherUpdate.");
+  }
+
+cleanup:
+  if (input_bytes != NULL) {
+    (*env)->ReleaseByteArrayElements(env, input, (jbyte *) input_bytes, 0);
+  }
+  return output_len;
+}
+
+JNIEXPORT jint JNICALL Java_org_apache_commons_crypto_cipher_OpenSsl3Native_doFinal
+  (JNIEnv *env, jclass clazz, jlong ctx, jobject output, jint offset,
+   jint max_output_len)
+{
+  EVP_CIPHER_CTX *context = get_context(env, ctx);
+  if (context == NULL) {
+    return 0;
+  }
+
+  if (!check_doFinal_max_output_len(env, context, max_output_len)) {
+    THROW(env, "javax/crypto/ShortBufferException",  \
+    "Output buffer is not sufficient.");
+    return 0;
+  }
+  unsigned char *output_bytes = (*env)->GetDirectBufferAddress(env, output);
+  if (output_bytes == NULL) {
+    THROW(env, "java/lang/InternalError", "Cannot get buffer address.");
+    return 0;
+  }
+  output_bytes = output_bytes + offset;
+
+  int output_len = 0;
+  if (!dlsym_EVP_CipherFinal_ex(context, output_bytes, &output_len)) {
+    // validate tag in GCM mode when decrypt
+    if (is_bad_tag(CTX_WRAPPER(ctx))) {
+      THROW(env, "javax/crypto/AEADBadTagException", "Tag mismatch!");
+    } else {
+      THROW(env, "java/lang/InternalError", "Error in EVP_CipherFinal_ex.");
+    }
+    return 0;
+  }
+  return output_len;
+}
+
+JNIEXPORT jint JNICALL Java_org_apache_commons_crypto_cipher_OpenSsl3Native_doFinalByteArray
+  (JNIEnv *env, jclass clazz, jlong ctx, jbyteArray output, jint offset,
+   jint max_output_len)
+{
+  EVP_CIPHER_CTX *context = get_context(env, ctx);
+  if (context == NULL) {
+    return 0;
+  }
+
+  if (!check_doFinal_max_output_len(env, context, max_output_len)) {
+    THROW(env, "javax/crypto/ShortBufferException",  \
+    "Output buffer is not sufficient.");
+    return 0;
+  }
+  unsigned char *output_bytes = (unsigned char *) (*env)->GetByteArrayElements(env, output, 0);
+  if (output_bytes == NULL) {
+    THROW(env, "java/lang/InternalError", "Cannot get buffer address.");
+    return 0;
+  }
+
+  int output_len = 0;
+  int rc = dlsym_EVP_CipherFinal_ex(context, output_bytes + offset, &output_len);
+
+  (*env)->ReleaseByteArrayElements(env, output, (jbyte *) output_bytes, 0);
+
+  if (rc == 0) {
+    // validate tag in GCM mode when decrypt
+    if (is_bad_tag(CTX_WRAPPER(ctx))) {
+    THROW(env, "javax/crypto/AEADBadTagException", "Tag mismatch!");
+    } else {
+    THROW(env, "java/lang/InternalError", "Error in EVP_CipherFinal_ex.");
+    }
+    return 0;
+  }
+  return output_len;
+}
+
+JNIEXPORT jint JNICALL Java_org_apache_commons_crypto_cipher_OpenSsl3Native_ctrl
+  (JNIEnv *env, jclass clazz, jlong ctx, jint type, jint arg, jbyteArray data)
+{
+  EVP_CIPHER_CTX *context = get_context(env, ctx);
+  if (context == NULL) {
+    return 0;
+  }
+
+  int rc = 0;
+  void *data_ptr = NULL;
+  if (data != NULL) {
+    data_ptr = (void*) (*env)->GetByteArrayElements(env, data, 0);
+    if (data_ptr == NULL) {
+      THROW(env, "java/lang/InternalError", "Cannot get buffer address.");
+      return 0;
+    }
+  }
+
+  // get/set tag for GCM
+  if (type == EVP_CTRL_GCM_GET_TAG || type == EVP_CTRL_GCM_SET_TAG) {
+    if (arg <= 0 || arg > 16) {
+      THROW(env, "javax/crypto/AEADBadTagException", "TAG_LENGTH_INTERNAL_ERROR");
+      goto exit_;
+    }
+    if (data == NULL) {
+      THROW(env, "javax/crypto/AEADBadTagException", "tag is null");
+      goto exit_;
+    }
+
+    unsigned char *tag = (unsigned char*) data_ptr;
+    rc = dlsym_EVP_CIPHER_CTX_ctrl(context, type, arg, tag);
+    if (!rc) {
+      THROW(env, "javax/crypto/AEADBadTagException", "TAG_SET_ERROR or TAG_RETRIEVE_ERROR");
+      goto exit_;
+    }
+  } else {
+    THROW(env, "java.lang.UnsupportedOperationException", "Not implemented yet!");
+    goto exit_;
+  }
+
+exit_:
+  if (data_ptr != NULL) {
+    (*env)->ReleaseByteArrayElements(env, data, (jbyte *) data_ptr, 0);
+  }
+  return rc;
+}
+
+
+JNIEXPORT void JNICALL Java_org_apache_commons_crypto_cipher_OpenSsl3Native_clean
+  (JNIEnv *env, jclass clazz, jlong ctx)
+{
+  EVP_CTX_Wrapper *wrapper = CTX_WRAPPER(ctx);
+  free_context_wrapper(wrapper);
+}
+
+static int check_update_max_output_len(EVP_CTX_Wrapper *wrapper, int input_len, int max_output_len)
+{
+  if (dlsym_EVP_CIPHER_CTX_test_flags(wrapper->ctx, EVP_CIPH_NO_PADDING) == EVP_CIPH_NO_PADDING) {
+    if (max_output_len >= input_len) {
+      return 1;
+    }
+    return 0;
+  } else {
+    int b = dlsym_EVP_CIPHER_CTX_get_block_size(wrapper->ctx);
+    if (wrapper->encrypt) {
+      if (max_output_len >= input_len + b - 1) {
+        return 1;
+      }
+    } else {
+      if (max_output_len >= input_len + b) {
+        return 1;
+      }
+    }
+    return 0;
+  }
+}
+
+static int check_doFinal_max_output_len(JNIEnv *env, EVP_CIPHER_CTX *context, int max_output_len)
+{
+  if (dlsym_EVP_CIPHER_CTX_test_flags(context, EVP_CIPH_NO_PADDING) == EVP_CIPH_NO_PADDING) {
+    return 1;
+  } else {
+    int b = dlsym_EVP_CIPHER_CTX_get_block_size(context);
+    if (max_output_len >= b) {
+      return 1;
+    }
+    return 0;
+  }
+}
+
+static int is_bad_tag(EVP_CTX_Wrapper *wrapper)
+{
+  EVP_CIPHER* ciph = dlsym_EVP_CIPHER_CTX_cipher(wrapper->ctx);
+  unsigned long flags = dlsym_EVP_CIPHER_get_flags(ciph);
+  if ((flags & EVP_CIPH_MODE) == EVP_CIPH_GCM_MODE && wrapper->encrypt == DECRYPT_MODE) {
+    return 1;
+  }
+  return 0;
+}
