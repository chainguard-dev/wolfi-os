diff --git a/src/apprentice.c b/src/apprentice.c
index cf040cdd..c77001f3 100644
--- a/src/apprentice.c
+++ b/src/apprentice.c
@@ -32,7 +32,7 @@
 #include "file.h"
 
 #ifndef	lint
-FILE_RCSID("@(#)$File: apprentice.c,v 1.356 2024/11/27 15:37:00 christos Exp $")
+FILE_RCSID("@(#)$File: apprentice.c,v 1.363 2025/01/25 16:11:03 christos Exp $")
 #endif	/* lint */
 
 #include "magic.h"
@@ -341,7 +341,11 @@ get_standard_integer_type(const char *l, const char **t)
 {
 	int type;
 
-	if (isalpha(CAST(unsigned char, l[1]))) {
+	if (l[0] == '\0')
+		return FILE_INVALID;
+	if (l[1] == '\0')
+		return FILE_INVALID;
+	else if (isalpha(CAST(unsigned char, l[1]))) {
 		switch (l[1]) {
 		case 'C':
 			/* "dC" and "uC" */
@@ -2391,6 +2395,12 @@ parse(struct magic_set *ms, struct magic_entry *me, const char *file,
 		}
 		break;
 	}
+
+	if (*l == '\0') {
+		file_magwarn(ms, "incomplete magic `%s'", line);
+		return -1;
+	}
+
 	/*
 	 * Grab the value part, except for an 'x' reln.
 	 */
@@ -3377,7 +3387,7 @@ check_buffer(struct magic_set *ms, struct magic_map *map, const char *dbname)
 	int i, needsbyteswap;
 
 	entries = CAST(uint32_t, map->len / sizeof(struct magic));
-	if (entries < MAGIC_SETS + 1) {
+	if (entries < MAGIC_SETS) {
 		file_error(ms, 0, "Too few magic entries %u in `%s'",
 		    entries, dbname);
 		return -1;
